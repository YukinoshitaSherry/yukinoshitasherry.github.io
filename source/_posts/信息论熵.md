---
title: 信息论基础
date: 2023-10-20
categories:
  - 学AI/DS
tags:
  - ML
desc: 各种熵Entropy的概念与计算公式汇总。
---

- 参考：<a href="https://www.showmeai.tech/article-detail/164">`showmeai.tech`</a>

### 发展脉络

信息论的发展可以追溯到19世纪中叶，经历了以下几个重要阶段：

1. 热力学阶段（1854年）
   - 克劳修斯首次提出"熵"的概念
   - 热力学第二定律的提出
   - 奠定了熵的物理基础

2. 统计力学阶段（1877年）
   - 玻尔兹曼将熵与微观状态数联系起来
   - 建立了熵的统计解释
   - 公式：$S = k \ln W$

3. 信息论阶段（1948年）
   - 香农发表《通信的数学理论》
   - 将熵引入信息论
   - 建立了现代信息论的基础

### 熵
**Entropy**

#### 概念


熵是描述系统混乱程度或不确定性的度量。在信息论中，熵表示随机变量的不确定程度，即信息量的大小。

#### 物理意义


1. 热力学意义
   - 描述系统的混乱程度
   - 表征能量分布的均匀程度
   - 反映系统的可逆性

2. 信息论意义
   - 表示信息的不确定性
   - 度量信息的平均信息量
   - 反映信息的可压缩性

#### 数学定义


对于随机变量 $X$，其可能的取值为 $x_1, x_2, ..., x_n$，概率分布为 $P(X=x_i)=p_i$，则随机变量 $X$ 的熵定义为：

$$H(X) = -\sum_{i=1}^n p_i \log p_i$$

#### 性质

1. 非负性：$H(X) \geq 0$
2. 对称性：$H(X_1,X_2,...,X_n) = H(X_{\pi(1)},X_{\pi(2)},...,X_{\pi(n)})$
3. 可加性：$H(X,Y) = H(X) + H(Y|X)$
4. 极值性：$H(X) \leq \log |X|$

<br>

### 联合熵
**Joint Entropy**

#### 概念

联合熵用于描述多个随机变量共同的不确定性。

#### 数学定义

对于分布为 $P(X,Y)$ 的一对随机变量 $(X,Y)$，其联合熵定义为：

$$H(X,Y) = -\sum_{x \in X} \sum_{y \in Y} P(x,y) \log P(x,y)$$



### 条件熵
**Conditional Entropy**

#### 概念

条件熵描述在已知一个随机变量的条件下，另一个随机变量的不确定性。

#### 数学定义
$Y$ 的条件熵是指在随机变量 $X$ 发生的前提下，随机变量 $Y$ 发生新带来的熵：

$$H(Y|X) = -\sum_{x \in X} \sum_{y \in Y} P(x,y) \log P(y|x)$$


### 相对熵
**Kullback–Leibler Divergence(KL散度)**

#### 概念

相对熵（KL散度）用于衡量两个概率分布的差异程度。
它描述了当我们用概率分布Q来拟合真实分布P时，产生的信息损耗。
KL散度是两个概率分布 P和 Q 差别的非对称性的度量。KL 散度越小表示两个分布越接近。
- KL散度是不对称的
- KL散度的值是非负数(=交叉熵-熵)


#### 数学定义
**Mathematical Definition**

对于两个概率分布 $P$ 和 $Q$，其相对熵定义为：

$$D_{KL}(P||Q) = \sum\_{i} P(i) \log \frac{P(i)}{Q(i)}$$


### 交叉熵
**Cross Entropy**

#### 概念
**Concept**

交叉熵用于度量两个概率分布间的差异性，在机器学习中常用作损失函数。
它衡量了使用概率分布Q来表示真实分布P时所需的平均比特数。

**在分类问题中，它通常用于衡量模型的预测分布与实际标签分布之间的差异。**
其中，p表示真实标签，q表示模型预测的标签，N 表示样本数量。该公式可以看作是一个基于概率分布的比较方式即将真实标签看做一个概率分布，将模型预测的标签也看做一个概率分布，然后计算它们之间的交叉熵。

物理意义:交叉熵损失函数可以用来衡量实际标签分布与模型预测分布之间的"信息差"。当两个分布完全一致时，交叉熵损失为 0，表示模型的预测与实际情况完全吻合。当两个分布之间存在差异时，损失函数的值会增加，表示预测错误程度的大小。

#### 数学定义

$$H(P,Q) = -\sum_{i}^N P(i) \log Q(i)$$

#### 与相对熵的关系

KL散度（相对熵）与交叉熵、熵的详细推导如下：

$$
D(P\|\|Q) = \sum\_{i=1}^n P(x_i) \log ( \frac{P(x_i)}{Q(x_i)} ) 
$$

$$
= \sum\_{i=1}^n P(x_i) \log P(x_i) - \sum\_{i=1}^n P(x_i) \log Q(x_i) 
$$

$$
= -H(P(x)) + [ -\sum\_{i=1}^n P(x_i) \log Q(x_i) ]
$$

交叉熵可以看作是相对熵（KL散度）加上熵：
$$D_{KL}(P||Q) = H(P,Q) - H(P)$$
其中：
- $H(P,Q)$ 是交叉熵
- $H(P)$ 是真实分布P的熵
- $D_{KL}(P||Q)$ 是相对熵


#### 应用
1. 分类任务
   - 二分类：二元交叉熵
   - 多分类：多元交叉熵
   - 序列分类：序列交叉熵

2. 为什么选择交叉熵作为损失函数
   - 真实概率分布P是确定的，因此熵H(P)是一个常量
   - 最小化交叉熵等价于最小化相对熵
   - 交叉熵的计算公式更简单，数值稳定性更好
   - 梯度计算更加直接，有利于反向传播

3. 优化特性
   - 非负性：$H(P,Q) \geq 0$
   - 当P=Q时取得最小值
   - 对异常值不敏感
   - 梯度计算简单，有利于模型训练

<br>

### 互信息
**Mutual Information**

#### 概念

互信息描述两个随机变量之间的相互依赖程度。
互信息是信息论里一种有用的信息度量方式，它可以看成是一个随机变量中包含的关于另一个随机变量的信息量，或者说是一个随机变量由于已知另一个随机变量而减少的不肯定性。

#### 数学定义

$$I(X;Y) = \sum_{x \in X} \sum_{y \in Y} P(x,y) \log \frac{P(x,y)}{P(x)P(y)}$$

<br>

### 最大熵原理
**Maximum Entropy Principle**


#### 数学定义
**Mathematical Expression**

对于随机变量 $X$ 的概率分布 $P(X)$，其熵满足：

$$H(X) \leq \log |X|$$

当且仅当 $X$ 服从均匀分布时等号成立。

#### 应用


**Machine Learning**：

1. 损失函数
   - 交叉熵损失
   - KL散度损失
   - 互信息最大化

2. 特征选择
   - 信息增益
   - 互信息特征选择
   - 最大相关最小冗余

**Deep Learning**：

1. 信息瓶颈理论
   - 压缩与预测的权衡
   - 表示学习
   - 模型解释性

2. 生成模型
   - 变分自编码器
   - 生成对抗网络
   - 扩散模型

### 总结

| 概念 | 英文 | 定义 | 物理意义 | 应用场景 |
|------|------|------|----------|----------|
| 熵 | Entropy | $H(X) = -\sum p_i \log p_i$ | 随机变量的不确定度 | 信息压缩、特征选择 |
| 联合熵 | Joint Entropy | $H(X,Y) = -\sum P(x,y) \log P(x,y)$ | 多随机变量系统的不确定度 | 多变量分析 |
| 条件熵 | Conditional Entropy | $H(Y\|X) = -\sum P(x,y) \log P(y\|x)$ | 已知X条件下Y的不确定度 | 条件概率建模 |
| 相对熵 | KL Divergence | $D_{KL}(P\|\|Q) = \sum P(i) \log \frac{P(i)}{Q(i)}$ | 两个概率分布的差异 | 模型评估、变分推断 |
| 交叉熵 | Cross Entropy | $H(P,Q) = -\sum P(i) \log Q(i)$ | 两个概率分布间的差异 | 分类任务损失函数 |
| 互信息 | Mutual Information | $I(X;Y) = \sum P(x,y) \log \frac{P(x,y)}{P(x)P(y)}$ | 变量间的相互依赖程度 | 特征选择、表示学习 |

<br>


### 问题集

#### 交叉熵与相对熵的区别？
| 维度           | 交叉熵（Cross-Entropy）                 | 相对熵 / KL 散度（KL Divergence）                           |
| ------------ | ---------------------------------- | ---------------------------------------------------- |
| **定义**       | H(P,Q)=−∑<sub>x</sub>P(x) log Q(x) | D<sub>KL</sub>(P‖Q)=∑<sub>x</sub>P(x) log(P(x)/Q(x)) |
| **含义**       | “用 Q 去编码 P 所需的平均码长”                | “用 Q 编码比用 P 编码多花的额外码长”                               |
| **是否对称**     | 否：H(P,Q)≠H(Q,P)                    | 否：D<sub>KL</sub>(P‖Q)≠D<sub>KL</sub>(Q‖P)            |
| **取值范围**     | \[0,+∞)                            | \[0,+∞)                                              |
| **是否含 P 的熵** | 是：H(P,Q)=H(P)+D<sub>KL</sub>(P‖Q)  | 否：D<sub>KL</sub>本身已扣掉了 P 的熵                          |
| **最小值意义**    | Q=P 时最小，值为 H(P)                    | Q=P 时最小，值为 0                                         |
| **机器学习角色**   | 分类损失：−∑ y log p̂                   | 正则项、变分推断、生成模型                                        |
| **一句话记忆**    | “衡量 Q 与 P 的编码代价”                   | “衡量 Q 与 P 的差异距离”                                     |

<br>

#### 多任务学习各 loss 差异过大怎样处理？

多任务学习中，如果各任务的损失（loss）差异过大，容易导致模型训练时某些任务主导优化过程，其他任务被忽略。常见的处理方法有：

1. **动态调整损失权重**：根据各任务损失的大小动态分配权重，使每个任务的损失对总损失的贡献更加均衡。
   - 使用不同比例的加权和：如 total_loss = w1 * loss1 + w2 * loss2 + ...，初始可设为等权，训练过程中动态调整。
   - 采用不变性损失归一化（例如GradNorm、Dynamic Weight Average等方法），自动平衡各任务loss。
   - 监控各任务loss的变化，若某任务loss长期偏大，可人为提升其权重，反之亦然。
2. **归一化各任务损失**：对不同任务的损失进行归一化或标准化，消除量纲和尺度的影响。
   - 对每个任务的loss先做标准化（如z-score），再加权求和。
3. **使用任务特定的损失函数**：针对不同任务选择合适的损失函数，提升每个任务的表现。
4. **改变模型架构**：为不同任务设计专属的分支或参数，提高模型对各任务的适应能力。
5. **引入正则化或不平衡损失惩罚**：通过正则化项或惩罚机制，抑制某些任务损失过大或过小。
   - 采用多任务不平衡采样，提升难学任务的样本比例。

目标是平衡各任务的贡献，使模型能够兼顾所有任务的学习效果。

<br>

#### 分类问题为什么用交叉熵损失函数不用均方误差(MSE)?

交叉熵损失函数通常用于分类问题，而均方误差（MSE）损失函数多用于回归问题。主要原因如下：

1. **统计学角度——最大似然估计**
   - 分类问题常假设数据服从伯努利分布（二分类）或多项式分布（多分类），交叉熵损失等价于最大化似然函数。
   - MSE假设误差服从高斯分布，更适合回归问题（预测连续值），不适合离散的分类任务。

2. **交叉熵损失权重更新更快**
   - MSE：sigmoid激活时，输出接近0或1时梯度趋于平坦，导致参数更新缓慢。
   - 交叉熵：没有sigmoid导数项，权重更新更受真实标签与预测概率差异影响，误差大时更新快，误差小时更新慢，优化效率高。

3. **凸优化问题**
   - MSE在分类场景下是非凸优化问题，容易陷入局部最优。
   - 交叉熵损失在softmax等激活下是凸优化问题，优化更稳定。

4. **概率解释与数值稳定性**
   - 交叉熵直接度量概率分布之间的信息差异，具有明确的信息论意义。
   - 交叉熵结合softmax等激活函数时，数值更稳定。
   - MSE不适合概率分布的比较，容易导致输出概率不归一。

**结论：**
- 分类问题推荐使用交叉熵损失函数，能更好地拟合概率分布、优化效率高、数值稳定。
- 回归问题推荐使用MSE损失函数，适合连续数值预测。

**具体做法举例：**
- 分类模型输出层用softmax（多分类）或sigmoid（二分类），损失函数选用交叉熵（cross entropy）。
- 回归模型输出层直接输出连续值，损失函数选用MSE。
- 若用MSE做分类，模型收敛慢且准确率低，建议直接切换为交叉熵损失。
- 框架如PyTorch、TensorFlow等，分类任务建议用`nn.CrossEntropyLoss`或`tf.keras.losses.CategoricalCrossentropy`。

<br>

#### 什么是信息增益？

信息增益是在决策树算法中用于选择最优特征的一种评价指标。在决策树的生成过程中，选择最优特征进行节点分裂的是关键信息之一，信息增益可以用来衡量特征的有效性。

信息增益量化了在特征已知的情况下，将样本集合分成不同类别的纯度提升程度。它基于信息论的概念，使用熵来度量样本集合的"不确定性"。

具体而言，信息增益是指在给定特征的条件下，样本集合的熵与特征划分下的条件熵的差异。

公式：
$$
IG(D, A) = H(D) - H(D|A)
$$
其中 $H(D)$ 是数据集D的熵，$H(D|A)$ 是特征A条件下的条件熵。

信息增益越大，说明该特征对分类越有用。

**具体做法举例：**
- 在决策树（如ID3、C4.5）训练时，遍历所有特征，计算每个特征分裂带来的信息增益，选择信息增益最大的特征作为分裂点。
- 可用sklearn的DecisionTreeClassifier，criterion参数设为"entropy"，自动用信息增益选特征。
- 信息增益小的特征可在特征工程阶段剔除。

<br>

#### 多分类的分类损失函数（Softmax）

多分类的分类损失函数常用Softmax交叉熵（Softmax Cross Entropy）损失函数。Softmax函数可以将输出值归一化为概率分布，适用于多分类问题的输出层。

Softmax交叉熵损失公式：
$$
L = -\sum_{i=1}^n y_i \log(p_i)
$$
其中：
- $n$ 是类别数
- $y_i$ 是第 $i$ 类的真实标签（one-hot编码）
- $p_i$ 是第 $i$ 类的预测概率

**具体做法举例：**
- 输出层神经元个数等于类别数，激活函数用softmax。
- 标签用one-hot编码，损失函数用交叉熵。
- 代码实现：如PyTorch的`nn.CrossEntropyLoss`、TensorFlow的`CategoricalCrossentropy`。
- 预测时取softmax输出概率最大的类别作为最终分类。

<br>

#### softmax和交叉熵损失怎么计算，二值交叉熵？

**softmax计算公式：**
$$
\text{softmax}(z_i) = \frac{e^{z_i}}{\sum_{j=1}^n e^{z_j}}
$$

**多分类交叉熵损失：**
$$
L = -\sum_{i=1}^n y_i \log(p_i)
$$

**二值交叉熵损失（Binary Cross Entropy）：**
$$
L = -[y \log(p) + (1-y)\log(1-p)]
$$
其中 $y$ 是真实标签（0或1），$p$ 是预测概率。

**具体做法举例：**
- 多分类：输出层用softmax，标签one-hot，损失用交叉熵。
- 二分类：输出层用sigmoid，标签0/1，损失用二元交叉熵。
- 代码实现：PyTorch的`nn.BCELoss`（二分类）、`nn.CrossEntropyLoss`（多分类）。
- 注意标签格式与损失函数类型要匹配。

<br>

#### softmax的e次方超出float怎么办？

在计算softmax时，$e^{z_i}$ 可能会因为 $z_i$ 过大导致数值溢出。常用的数值稳定技巧是：

对所有分子分母同时减去 $z$ 中的最大值，公式如下：
$$
\text{softmax}(z_i) = \frac{e^{z_i-\max(z)}}{\sum_{j=1}^n e^{z_j-\max(z)}}
$$
这样不会影响softmax的结果，但能有效避免数值溢出。

**具体做法举例：**
- 在实现softmax时，先用`max(z)`做数值平移，防止溢出。
- 绝大多数深度学习框架（如PyTorch、TensorFlow）自带的softmax实现都已自动做了数值稳定处理。
- 手写softmax时，务必加上`减去最大值`这一步。
- 训练中如遇到nan或inf，优先检查softmax实现是否数值稳定。