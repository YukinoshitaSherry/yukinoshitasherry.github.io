---
title: Agent Memory综述整理 
date: 2025-12-17
categories:
  - 学AI/DS
tags:
  - LLM
  - Agent
desc: 整理自 https://arxiv.org/abs/2512.13564 《Memory in the Age of AI Agents》
---

综述地址：
- <a href="https://arxiv.org/abs/2512.13564"> Memory in the Age of AI Agents </a>
<br>



## 1. 背景

### 动机

大语言模型（LLMs）虽然在单次对话中表现出色，但其本质上是**无状态的（stateless）** 。给定上下文窗口 $C$，LLM 只能处理长度不超过 $|C|$ 的输入序列，其中 $|C|$ 通常限制在 4K 到 128K tokens 之间。这种限制使得 LLM 无法在**跨会话、跨任务、长期运行**的场景中维持记忆。

形式化地，设 $M_t$ 表示时刻 $t$ 的记忆状态，$X_t$ 表示时刻 $t$ 的输入，则传统 LLM 的决策函数为：

$$a_t = f_{LLM}(X_t, C_t)$$

其中 $C_t \subseteq \{X_{t-k}, X_{t-k+1}, \ldots, X_{t-1}\}$ 是上下文窗口，$k \leq |C|$。当 $t$ 很大时，早期经验 $\{X_1, X_2, \ldots, X_{t-k-1}\}$ 被完全遗忘。

智能体（Agent）在复杂环境中持续运行，必须依赖**外部记忆系统** $\mathcal{M}$ 来维持长期状态。记忆系统 $\mathcal{M}$ 提供四个核心能力：行为一致性（behavioral consistency），使得 Agent 在不同时间对相同情境产生一致响应；个性化适应（personalization），根据用户历史行为定制响应；经验复用（experience reuse），从历史成功案例中学习；协作记忆（collaborative memory），在多 Agent 系统中共享知识。

### 核心贡献

本文提出 **Forms–Functions–Dynamics 三维分析框架**，首次系统性地将智能体记忆研究纳入统一范式。该框架将记忆系统分解为三个相互关联的维度：

**Forms（形式）** ：记忆的表示形式，回答"What architectural or representational forms can agent memory take"。
- 包括记忆的**编码方式**（结构化 vs 非结构化）、**粒度**（事件级 vs 知识级）、**存储介质**（向量、图、关系型数据库）等。
- 形式化地，记忆形式可以表示为 $m \in \mathcal{M}$，其中 $\mathcal{M}$ 是记忆空间，$m$ 可以是向量 $\mathbf{v} \in \mathbb{R}^d$、图节点 $n \in \mathcal{G}$、或结构化记录 $r \in \mathcal{R}$。

**Functions（功能）** ：记忆的用途，回答"Why is agent memory needed, and what roles or purposes does it serve"。
- 记忆系统支持五种核心功能：
  - **检索（Retrieval）** $\mathcal{R}: \mathcal{Q} \times \mathcal{M} \rightarrow \mathcal{M}'$，从记忆库中召回相关信
  - **反思（Reflection）** $\mathcal{F}: \mathcal{M}\_{episodic} \rightarrow \mathcal{M}\_{semantic}$，从具体经验中提炼抽象原则
  - **规划（Planning）** $\mathcal{P}: \mathcal{M}\_{procedural} \times \mathcal{T} \rightarrow \Pi$，基于历史计划生成新计划
  - **个性化（Personalization）** $\mathcal{U}: \mathcal{M}\_{episodic} \rightarrow \mathcal{P}\_{user}$，构建用户画像
  - **协作（Collaboration）** $\mathcal{C}: \{\mathcal{M}_i\}\_{i=1}^n \rightarrow \mathcal{M}\_{shared}$，多 Agent 记忆融合。

**Dynamics（动态）** ：记忆的演化机制，回答"How does agent memory operate, adapt, and evolve over time"。
- 记忆不是静态仓库，而是动态演化的认知器官。
- 动态机制包括：
  - **巩固（Consolidation）** $\mathcal{CON}: \mathcal{M}\_{short} \rightarrow \mathcal{M}\_{long}$，将短期记忆整合为长期知识
  - **更新（Updating）**  $\mathcal{UPD}: \mathcal{M}\_{old} \times \mathcal{E}\_{new} \rightarrow \mathcal{M}\_{new}$，根据新证据更新记忆
  - **遗忘（Forgetting）**  $\mathcal{FOR}: \mathcal{M} \times \mathcal{C} \rightarrow \mathcal{M}'$，移除过时或低价值记忆。


三个维度不可割裂。例如，"反思"功能要求高抽象语义记忆（Form），并通过全局整合（Dynamics）实现。形式化地，这种耦合关系可以表示为：
$$\mathcal{F}(\mathcal{M}\_{episodic}) = \mathcal{CON}(\mathcal{M}\_{episodic}, \text{abstraction}) \subseteq \mathcal{M}\_{semantic}$$

其中抽象操作将具体事件映射到语义空间。

<br>

## 2. 定义

<br>

### 基于 LLM 的 Agent 系统

#### Agents 与 Environment

**Agent 索引集合**：$I = \{1, \ldots, N\}$
- $N = 1$：单 Agent 场景（如 ReAct）
- $N > 1$：多 Agent 设置（辩论、规划器-执行器架构等）

**环境状态转移**：
$$s_{t+1} \sim \Psi(s_{t+1} | s_t, a_t)$$

**Agent 观测**：
$$o_t^i = O_i(s_t, h_i, Q)$$

其中：
- $h_i$：Agent $i$ 可见的交互历史（消息、工具输出、推理轨迹、共享工作空间状态等）
- $Q$：任务规范（用户指令、目标描述、外部约束），任务内固定

<br>

#### Action Space

**动作类型**：
- **自然语言生成**：中间推理、解释、响应、指令
- **工具调用**：外部 API、搜索引擎、计算器、数据库、模拟器、代码执行
- **规划动作**：任务分解、执行计划、子目标规范
- **环境控制**：导航、编辑仓库、修改共享内存
- **通信动作**：结构化消息、协作协商

**策略定义**：
$$a_t = \pi_i(o_t^i, m_t^i, Q)$$

其中 $m_t^i$ 是记忆导出的信号。

<br>

#### Interaction Process 与 Trajectories

**轨迹定义**：
$$\tau = (s_0, o_0, a_0, s_1, o_1, a_1, \ldots, s_T)$$

每一步包括：
1. 环境观测
2. 可选的记忆检索
3. 基于 LLM 的计算
4. 动作执行

<br>

### Agent Memory Systems

**记忆状态**：
$$M_t \in \mathcal{M}$$

- $M_t$：时间 $t$ 的记忆状态
- $\mathcal{M}$：可允许记忆配置的空间
- 结构：文本缓冲区、键值存储、向量数据库、图、混合形式
- 角色：跨试验记忆 + 任务特定记忆

<br>

#### Memory Lifecycle

**三个操作符**：

1. **Memory Formation（记忆形成）**
   $$M_{t+1}^{form} = F(M_t, \phi_t)$$
   - 输入：信息工件 $\phi_t$（工具输出、推理轨迹、自我评估）
   - 输出：记忆候选
   - 特点：选择性提取，不存储原始交互历史

2. **Memory Evolution（记忆演化）**
   $$M_{t+1} = E(M_t^{form})$$
   - 功能：巩固冗余、解决冲突、丢弃低效用信息、重组记忆
   - 特点：任务间持续存在

3. **Memory Retrieval（记忆检索）**
   $$m_t^i = R(M_t, o_t^i, Q)$$
   - 输出：上下文相关的记忆信号 $m_t^i$

<br>

#### Memory-Agent Coupling

**策略形式**：
$$a_t = \pi_t(o_t^i, m_t^i, Q)$$

**Agent 循环**：
观测 → 检索记忆 → 计算动作 → 接收反馈 → 更新记忆

<br>

### 与其他概念比较

#### vs. LLM Memory

**重叠**：
- Agent Memory 包含传统 LLM Memory 内容
- 短期、任务内记忆（KV 压缩、上下文窗口管理）

**区别**：
- **LLM Memory**：架构修改（更长上下文、缓存重写、循环状态持久化、注意力稀疏性、外部化 KV 存储）
- **不支持**：跨任务持久化、环境驱动适应、故意记忆操作
- **Agent Memory**：支持跨任务持久化、环境驱动适应、故意记忆操作

<br>

#### vs. RAG

**重叠**：
- 辅助信息存储扩展 LLM/Agent 能力
- 结构化表示（知识图谱）、索引策略
- 向量索引、语义搜索、上下文扩展

**历史区别**：
- **经典 RAG**：
  - 静态知识源（文档存储、知识库、语料库）
  - 外部索引、按需检索
  - 不维护过去交互的内部、演化记忆
- **Agent Memory**：
  - 持续交互中实例化
  - 持续纳入新信息到持久记忆库

**实际区别（任务领域）**：
- **RAG**：大型推理任务（HotpotQA、2WikiMQA、MuSiQue）
- **Agent Memory**：持续多轮交互、时间依赖、环境驱动适应（长上下文对话、复杂问题解决、代码任务、终身学习）

**RAG 分类关系**：

1. **Modular RAG（模块化 RAG）**
   - 静态管道式检索
   - 外部、模块化子系统
   - Agent Memory 框架：Memary、MemOS、Memo

2. **Graph RAG（图 RAG）**
   - 知识库结构化为图
   - 图遍历、多跳推理
   - Agent Memory 实践：Mem09、A-MEM、Zep、G-memory
   - **关键区别**：Agent Memory 可在操作期间构建、扩展、重组内部图

3. **Agentic RAG（Agentic RAG）**
   - 自主决策循环
   - 主动控制检索
   - **主要区别**：
     - Agentic RAG：外部、任务特定数据库
     - Agent Memory：内部、持久、自演化记忆库，跨任务积累

<br>

#### vs. Context Engineering

**关系**：不同操作范式的交集（非层次关系）

**Context Engineering**：
- 系统化设计方法论
- 上下文窗口 = 受约束的计算资源
- 优化信息负载
- 资源管理范式

**重叠**：
- 长视野交互中工作记忆的技术实现
- 共享机制：信息压缩、组织、选择技术
- Token 修剪、基于重要性的选择
- 滚动摘要（缓冲区管理、瞬态情景记忆）

**区别**：

| 维度 | Context Engineering | Agent Memory |
|------|---------------------|--------------|
| **范围** | 交互接口的结构组织 | 更广泛的认知范围 |
| **目标** | 信息如何呈现给模型 | Agent 知道什么、经历了什么 |
| **操作层面** | 资源分配、接口正确性 | 持久存储、经验积累、记忆演化 |
| **包括** | 工具集成、通信协议 | 事实知识、经验轨迹、程序知识、连贯身份 |
| **类比** | 外部脚手架、瞬时接口 | 内部基质、持久认知状态 |

<br>

<br>



<br>

## 3. Formats

记忆形式的分类遵循一个核心问题：**记忆以何种架构或表示形式存在？**（What architectural or representational forms can agent memory take?）

不同任务场景需要不同的存储形式，每种形式具有独特的结构属性。这些架构赋予记忆不同的能力，塑造 Agent 如何积累信息并维持行为一致性，最终使记忆能够在各种任务场景中发挥预期作用。

基于记忆的**存储位置**和**表示形式**，我们将记忆形式分为三大类：

**三大记忆形式**：

1. **Token-level Memory（Token 级记忆）**（第 3.1 节）：记忆组织为显式、离散的单元，可单独访问、修改和重构。这些单元保持外部可见，可以结构化形式长期存储。

2. **Parametric Memory（参数记忆）**（第 3.2 节）：记忆存储在模型参数中，信息通过参数空间的统计模式编码，在前向计算过程中隐式访问。

3. **Latent Memory（潜在记忆）**（第 3.3 节）：记忆表示为模型内部隐藏状态、连续表示或演化的潜在结构。它可以在推理过程中或跨交互周期持续存在和更新，捕获上下文相关的内部状态。

这三种记忆形式建立了理解"什么承载记忆"的核心结构框架。每种形式以不同方式组织、存储和更新信息，产生不同的表示模式和行为特征。在此基础上，我们可以更系统地审视 Agent 为什么需要记忆（第 4 节）以及记忆如何演化、适应并塑造 Agent 行为（第 5 节）。

<br>

### 3.1 Token-level Memory

#### 定义

**Token-level Memory** 将信息存储为**持久、离散的单元**，这些单元外部可访问、可检查。这里的"token"是广义的表示概念：不仅包括文本 token，还包括视觉 token、音频帧——任何可以写入、检索、重组和修订的离散元素。

形式化定义：
- 记忆单元集合：$\mathcal{M}\_{token} = \{m_i\}\_{i=1}^n$
- 每个单元：$m_i = \langle \text{content}, \text{metadata}, \text{timestamp} \rangle$
  - $\text{content}$：记忆内容（文本、图像、音频等）
  - $\text{metadata}$：元数据（用户 ID、任务类型等）
  - $\text{timestamp}$：时间戳

**核心特征**：
- **显式性**：记忆单元外部可见、可编辑
- **透明性**：易于解释和理解
- **可操作性**：支持检索、路由、冲突处理
- **可扩展性**：易于与参数记忆和潜在记忆协调

由于这些单元是显式的，Token-level Memory 通常是透明的、易于编辑的、易于解释的，使其成为检索、路由、冲突处理以及与参数记忆和潜在记忆协调的自然层。Token-level Memory 也是最常见的记忆形式，现有工作最多。

虽然所有 Token-level Memory 都共享作为离散单元存储的属性，但它们在**单元组织方式**上存在显著差异。存储 token 的结构组织在决定 Agent 如何高效搜索、更新或推理过去信息方面发挥核心作用。为了描述这些差异，我们按单元间结构组织对 Token-level Memory 进行分类，从无显式拓扑到多层拓扑：

**Token-level Memory 的三大类型**：

1. **Flat Memory（1D，扁平记忆）**：无显式单元间拓扑。记忆作为序列或单元包累积（如片段、轨迹、块）

2. **Planar Memory（2D，平面记忆）**：单一平面内的结构化但单层组织：单元通过图、树、表等关联，无跨层关系。结构显式，但不分层。

3. **Hierarchical Memory（3D，分层记忆）**：跨多个层的结构化，具有层间链接，形成体积或分层记忆。

这三种类型从无拓扑的扁平记忆，到单层结构组织的平面记忆，再到多层互连结构的分层记忆，这一组织谱系不仅决定了 Token-level Memory 如何支持搜索、更新和推理，还决定了记忆本身的结构及其提供的能力。

<br>

#### 3.1.1 Flat Memory（1D，扁平记忆）

**定义**：

Flat Memory 将信息存储为离散单元的累积，**不显式建模单元间的语义或关系依赖**。这些单元可能包括文本块、用户画像、经验轨迹、对应的向量表示或多模态条目。这些单元之间的关系不直接在记忆中编码。

形式化定义：
- 记忆集合：$\mathcal{M}\_{flat} = \{m_i\}\_{i=1}^n$
- 无显式关系：$\nexists R(m_i, m_j)$，其中 $R$ 表示关系函数
- 组织方式：序列或集合
  - 序列：$\mathcal{M}\_{flat} = [m_1, m_2, \ldots, m_n]$（按时间顺序）
  - 集合：$\mathcal{M}\_{flat} = \{m_1, m_2, \ldots, m_n\}$（无序）

**核心特征**：
- **无拓扑结构**：单元间无显式关系编码
- **简单累积**：通过追加或删除单元进行更新
- **灵活检索**：通过相似性搜索等方法灵活访问
- **低维护成本**：添加或修剪记忆成本低

为了便于清晰连贯的呈现，我们根据主要设计目标和技术重点对扁平记忆的现有工作进行分组。这种分组服务于组织目的，并不意味着结果类别严格平行或互斥。在实践中，某些方法可能适用于多个类别，一些涉及多模态信息的方法可能在多模态不是其核心焦点时在其他章节讨论。

**主要类别**：

##### Memory for Dialogue（对话记忆）

专注于存储和管理对话内容。早期方法主要关注通过存储原始对话历史或生成递归摘要来防止遗忘，以扩展上下文窗口。

**代表工作**：
- **MemGPT**（Packer et al., 2023a）：引入操作系统隐喻，采用分层管理，将活动上下文与外部存储解耦，实现无限上下文管理
- **COMEDY**（Chen et al., 2025c）：将信息压缩为紧凑的语义表示或查询-响应对，便于直接查找
- **Memory Sharing**（Gao and Zhang, 2024a）：多 Agent 系统中的记忆共享机制
- **MemGuide**（Du et al., 2025b）：记忆引导的对话系统

**技术实现**：
- **存储**：向量数据库、文档数据库
- **检索**：相似性搜索、语义匹配
- **压缩**：摘要生成、语义压缩

**应用场景**：
- 多轮对话系统
- 长期对话维护
- 上下文窗口扩展

随着对话深度增加，记忆演化为存储高级认知过程和叙事复杂性。系统如 **Think-in-Memory**（Liu et al., 2023a）和 **RMM**（Tan et al., 2025c）存储归纳思维和回顾性反思，以指导未来推理。在复杂场景如角色扮演或长叙事中，**ComoRAG**（Wang et al., 2025f）和 **MOOM**（Chen et al., 2025d）将记忆分解为事实级、情节级和角色级组件，确保 Agent 在扩展交互中保持连贯的角色和理解。

记忆已从静态存储转变为自主和自适应优化。**Mem0**（Chhikara et al., 2025）建立了记忆维护的标准化操作，为智能控制奠定基础。最近进展引入强化学习来优化记忆构建（Yan et al., 2025b; Wang et al., 2025o），而其他机制专注于动态校准和效率，如预测缺失信息（Nan et al., 2025）、管理多 Agent 系统中的 token 预算（Liu et al., 2025c）以及减少长期存储中的冗余（Fang et al., 2025b）。

<br>

##### Preference（偏好记忆）

一些记忆系统专注于建模用户不断演化的品味、兴趣和决策模式，特别是在推荐场景中，偏好理解是核心。

**代表工作**：
- **RecMind**（Wang et al., 2024h）：将用户特定信息与外部领域知识分离，存储事实用户属性和项目元数据
- **InteRecAgent**（Huang et al., 2025d）：将记忆折叠到推荐工作流中，但更关注当前候选集，保持用户画像和活动项目池以支持上下文感知推荐
- **MR.Rec**（Huang et al., 2025b）：构建记忆索引，归档完整交互过程，存储原始项目信息和每类别偏好摘要
- **Memocrs**（Xi et al., 2024a）：在对话设置中提出更结构化设计，包含用户特定记忆（跟踪实体和用户态度）和通用记忆（聚合跨用户知识）

**技术实现**：
- **存储**：用户-项目交互矩阵、偏好向量
- **更新**：增量更新、时间加权
- **检索**：基于用户 ID 的查询、相似用户推荐

**应用场景**：
- 推荐系统
- 个性化服务
- 用户画像构建

<br>

##### Profile（画像记忆）

扁平记忆系统的子集专注于存储和维护稳定的用户画像、角色属性或长期身份信息，以便 Agent 在不同轮次和任务中行为一致。

**代表工作**：
- **MemoryBank**（Zhong et al., 2024）：最早框架之一，按时间戳组织对话历史和事件摘要，逐步构建支持准确检索身份相关信息的用户画像
- **AI Persona**（Wang et al., 2024f）：使记忆系统不仅处理对话上下文中呈现的信息，还处理多维人机交互维度的信息
- **MPC**（Lee et al., 2023）：扩展这一想法，在记忆池中存储实时角色信息和对话摘要，在长期交互中保持对话行为与一致角色对齐
- **Westhäußer et al.**（2025）：提出更全面的画像维护机制，结合长期和短期记忆，每轮后自动生成摘要形成中期上下文，允许用户画像通过交互持续演化

在虚拟角色扮演设置中，**ChatHaruhi**（Li et al., 2023a）从小说和电视剧本中提取对话，使模型能够通过检索记忆维持角色一致行为。**RoleLLM**（Wang et al., 2024d）采用更结构化方法，构建问答对以捕获角色特定知识。

**技术实现**：
- **存储**：结构化用户画像、角色属性数据库
- **更新**：增量更新、摘要生成
- **检索**：基于角色的查询、一致性检查

**应用场景**：
- 角色扮演系统
- 个性化助手
- 长期用户建模

<br>

##### Experience（经验记忆）

与静态、通用知识不同，经验记忆源于 Agent 在实际交互任务中的动态积累，包括特定观察、思维链、动作轨迹和环境反馈。需要注意的是，本节仅从 Token-level 存储的角度简要概述经验记忆；更全面的分析和详细讨论将在第 4.2 节呈现。

**形式化定义**：
- 经验集合：$\mathcal{M}\_{exp} = \{e_i\}\_{i=1}^n$
- 经验单元：$e = \langle \text{trajectory}, \text{observation}, \text{action}, \text{reward}, \text{feedback} \rangle$

经验记忆最基本的形式涉及历史行为轨迹的直接归档。这种范式使 Agent 能够通过检索和复用过去实例（包括成功和失败案例）为当前决策提供信息（Zhou et al., 2025a; Wang et al., 2025p）。

**代表工作**：
- **Reflexion**（Shinn et al., 2023b）：最早和最有影响力的方法之一，将短期记忆区分为轨迹历史，长期记忆区分为自反思模型产生的反馈
- **Wang et al.**（2024l）：将复杂交互历史压缩为通用工作流、规则模板或高级"思维模板"，以促进跨问题迁移和复用
- **Kim et al.**（2025a）、**Yang et al.**（2024b）：类似的经验抽象方法

某些研究强调记忆的结构化组织和动态维护。这些方法通过构建领域特定结构化知识库、采用分层计划-执行记忆架构或结合类人遗忘和反思机制，确保存储的见解保持适应新任务并高效更新（Tang et al., 2025c,d; Ouyang et al., 2025; Ye et al., 2025b; Zhao et al., 2024; Liang et al., 2025）。

在涉及编程或特定工具利用的上下文中，经验记忆演化为可执行技能。在此范式下，Agent 将探索经验整合到代码仓库、程序脚本或工具使用条目中。利用环境反馈，这些系统迭代改进代码质量，甚至动态修改其底层逻辑以实现自演化（Wang et al., 2024a; Yin et al., 2025; Fang et al., 2025d; Xiao et al., 2025b）。此外，针对复杂环境如操作系统，某些研究将成功执行记录提炼为可复用示例或向量化表示，从而促进从离线构建到在线分配的高效管道（Zhang et al., 2025a; Han et al., 2025a）。

**技术实现**：
- **存储**：轨迹数据库、代码仓库、向量表示
- **抽象**：从具体轨迹到抽象原则的映射
- **检索**：相似轨迹检索、案例匹配

**应用场景**：
- 强化学习
- 代码生成任务
- 工具使用学习

<br>

##### Multimodal（多模态记忆）

多模态记忆系统以从原始多模态数据（如图像、视频帧、音频段和文本）中提取的离散 Token-level 单元形式存储信息，使 Agent 能够跨通道和长时间跨度捕获、压缩和检索知识。

**代表工作**：
- **Ego-LLaVA**（Shen et al., 2024）：在可穿戴和以自我为中心设置中，捕获第一人称视频并将其转换为轻量级语言描述
- **Memoro**（Zulfikar et al., 2024）：遵循类似理念，但使用语音转文本形成基于嵌入的记忆块
- **Livia**（Xi and Wang, 2025）：将长期用户记忆整合到具有情感意识的 AR 系统中，应用遗忘曲线和修剪策略

对于视频理解，重点转向将瞬态视觉线索与持久上下文信息分离。**MovieChat**（Song et al., 2024）采用短期/长期分割，存储最近帧特征。**MA-LMM**（He et al., 2024）通过双库设计进一步推进——一个存储原始视觉特征，另一个保留查询嵌入。**VideoAgent**（Wang et al., 2024g）采用更语义组织的方法，维护文本片段描述的时间记忆以及跨帧跟踪实体的对象级记忆。在交互式视频生成中，**Context-as-Memory**（Yu et al., 2025b）表明，简单地将先前生成的帧存储为记忆也可以非常有效。

在具身场景中，记忆本质上与空间结构和持续交互相关。**KARMA**（Wang et al., 2025q）引入双层记忆系统：长期记忆在 3D 场景图中存储静态对象，短期记忆跟踪对象位置和状态变化。**Embodied VideoAgent**（Fan et al., 2025）也构建持久对象记忆，但将其与第一人称视频和额外具身传感器融合。**Mem2Ego**（Zhang et al., 2025l）将这一想法扩展到导航，将全局地图、地标描述和访问历史分离为三个不同的记忆存储。补充这些任务驱动设计，**MEMENTO**（Kwon et al., 2025）提供了一个评估框架，将多模态交互历史视为 Agent 的记忆，使系统能够系统评估具身系统如何利用累积的感知经验。

**技术实现**：
- **存储**：多模态向量数据库、时间序列存储
- **编码**：视觉编码器、音频编码器、文本编码器
- **检索**：跨模态检索、时间查询

**应用场景**：
- 视频理解
- 具身智能
- 多模态对话

<br>

**优势**：
- **简单性和可扩展性**：记忆可以以最小成本追加或修剪
- **灵活检索**：相似性搜索等方法允许灵活访问，无需预定义结构
- **广泛召回**：适合广泛召回、情景积累和快速变化的交互历史
- **易于实现**：实现和维护成本低

**劣势**：
- **缺乏显式关系组织**：连贯性和相关性严重依赖检索质量
- **冗余和噪声累积**：随着记忆增长，冗余和噪声可能累积
- **关系理解有限**：模型可能检索相关单元但不理解它们如何关联
- **推理能力受限**：限制组合推理、长期规划和抽象形成

因此，无拓扑集合在广泛覆盖和轻量级更新方面表现出色，但在需要结构化推理或稳定知识组织的任务中受到限制。

<br>

#### 3.1.2 Planar Memory（2D，平面记忆）

**定义**：

Planar Memory 在记忆单元之间引入**显式组织拓扑**，但仅在**单一结构层内**（简称为 2D）。拓扑可能是图、树、表、隐式连接结构等，其中邻接、父子排序或语义分组等关系在单一平面内编码，无分层级别或跨层引用。

形式化定义：
- 平面记忆：$\mathcal{M}\_{planar} = \langle V, E, \lambda \rangle$
  - $V = \{m_i\}\_{i=1}^n$：记忆单元集合（节点）
  - $E \subseteq V \times V$：单元间关系集合（边）
  - $\lambda: E \rightarrow \mathcal{L}$：边标签函数，$\mathcal{L}$ 是关系类型集合
- **单层约束**：$\nexists \text{layer}(m_i) \neq \text{layer}(m_j)$，所有单元在同一层

**核心特征**：
- **显式关系**：单元间关系显式编码
- **单层结构**：无分层，所有单元在同一平面
- **结构化组织**：通过图、树、表等结构组织
- **关系查询**：支持基于关系的查询和遍历

平面记忆形式的核心在于通过建立显式关联机制突破单一存储池，实现从单纯"存储"到"组织"的飞跃。

**主要类型**：

##### Tree（树结构）

树结构分层组织信息，可以处理不同抽象级别。

**代表工作**：
- **HAT**（A et al., 2024）：通过分割长交互然后逐步聚合构建分层聚合树。这种多级结构支持粗到细的检索，在长上下文问答中表现优于扁平向量索引
- **MemTree**（Rezazadeh et al., 2025c）：引入动态表示，从孤立对话日志推断分层模式。它逐步将具体事件总结为更高级概念，允许 Agent 使用详细记忆和抽象知识

**技术实现**：
- **存储**：树形数据结构、层次索引
- **查询**：从根到叶的路径查询、子树检索
- **更新**：节点插入、子树更新

**应用场景**：
- 长上下文处理
- 层次化知识组织
- 粗到细检索

<br>

##### Graph（图结构）

图结构在 2D 记忆中占主导地位，因为它们能够捕获复杂关联、因果关系和时间动态。

**代表工作**：
- **Ret-LLM**（Modarressi et al., 2023）：将外部存储抽象为可寻址的基于三元组的单元，使 LLM 能够与类似轻量级知识图谱的关系中心表交互
- **HuaTuo**（Wang et al., 2023a）：在医疗领域，通过整合中文医疗知识图谱和临床文本的结构化语料库将专业知识注入基础模型
- **KGT**（Sun et al., 2024）：引入实时个性化机制，其中用户偏好和反馈编码为用户特定知识图谱中的节点和边
- **PREMem**（Kim et al., 2025b）：对于推理密集型任务，将部分推理负担转移到记忆构建阶段，从原始对话中推导结构化记忆项及其演化关系
- **Memory-augmented Query Reconstruction**（Xu et al., 2025b）：维护专用查询记忆，记录过去 KG 查询和推理步骤，使用检索记录重建更准确的查询
- **TeaFarm**（iunn Ong et al., 2025）：从时间线视角构建，沿分段时间线组织对话历史，应用结构化压缩管理终身上下文
- **COMET**（Kim et al., 2024b）：通过使用外部常识库解析对话并动态更新具有推断隐藏属性的上下文感知角色图，进一步细化对话记忆
- **A-Mem**（Xu et al., 2025c）：将知识标准化为卡片式单元。它按相关性组织它们，将相关记忆放在同一框中，构建完整记忆网络
- **Intrinsic Memory Agents**（Yuen et al., 2025）：采用分区架构，其中子 Agent 维护自己的角色特定私有记忆，同时协作读写共享记忆
- **M3-Agent**（Long et al., 2025）：扩展到多模态 Agent，将图像、音频和文本统一为以实体为中心的记忆图
- **SALI**（Pan et al., 2024）：构建现实-想象混合记忆，将真实观察和想象的未来场景统一为一致的导航图

**技术实现**：
- **存储**：图数据库（Neo4j、Amazon Neptune）、知识图谱
- **查询**：图遍历、多跳查询、路径查找
- **更新**：节点/边添加、子图更新

**应用场景**：
- 知识图谱构建
- 关系推理
- 个性化推荐

<br>

##### Hybrid（混合结构）

复杂任务通常需要混合架构，将不同认知功能分离，同时共享共同记忆基质。

**代表工作**：
- **Optimus-1**（Li et al., 2024d）：显式将静态知识分离为用于规划的分层有向知识图，将动态交互分离为用于反思和自我改进的抽象多模态经验池
- **D-SMART**（Lei et al., 2025）：结合结构化事实记忆（实现为持续更新的知识图谱）和基于遍历的推理树

**技术实现**：
- **存储**：混合数据结构（图+表、图+向量）
- **查询**：多模式查询（图查询+向量搜索）
- **协调**：不同结构间的协调机制

**应用场景**：
- 复杂推理任务
- 多模态记忆
- 混合检索系统

<br>

**优势**：
- **集体协同**：通过有效建立节点间链接，记忆能够利用集体协同，从而编码更全面的上下文知识
- **结构化检索**：支持超越简单迭代的检索机制，包括结构化键值查找和沿图边的关系遍历
- **组织能力**：在存储、组织和管理记忆方面表现出色

**劣势**：
- **单层限制**：无分层存储机制，所有记忆必须整合到单一、整体模块中
- **复杂度增长**：随着任务场景复杂性和多样性增长，这种冗余和扁平设计变得不足以支持稳健性能
- **高成本**：高构建和搜索成本显著阻碍其实际部署
  - 构建复杂度：$O(|V|^2)$ 对于完全图
  - 查询复杂度：$O(|V| + |E|)$ 对于简单查询，$O(|V|^k)$ 对于 $k$-跳查询

<br>

#### 3.1.3 Hierarchical Memory（3D，分层记忆）

**定义**：

Hierarchical Memory 跨层组织信息，使用层间连接塑造记忆为体积结构化空间。这种层次结构支持不同抽象程度的表示——从原始观察到紧凑事件摘要，再到更高级的主题模式。跨层连接进一步产生体积记忆空间，系统不仅可以在单元间横向导航，还可以在抽象级别间纵向导航。

形式化定义：
- 分层记忆：$\mathcal{M}\_{hier} = \langle L, E\_{inter}, E\_{intra} \rangle$
  - $L = \{L_1, L_2, \ldots, L_k\}$：$k$ 个层次
  - $E\_{intra} = \bigcup\_{i=1}^k E_i$：层内边（每层内部的关系）
  - $E\_{inter} = \bigcup\_{i=1}^{k-1} E\_{i,i+1}$：层间边（跨层连接）
- **抽象层次**：$\text{abstraction}(L_i) < \text{abstraction}(L_{i+1})$，更高层更抽象

**核心特征**：
- **多层结构**：信息跨多个抽象层组织
- **层间连接**：支持跨层导航和查询
- **体积空间**：形成三维记忆空间（横向+纵向）
- **抽象能力**：从具体到抽象的表示谱系

分层记忆超越了简单分层，旨在构建具有深度抽象能力和动态演化机制的复杂系统。这些工作通常采用多级图结构或受神经科学启发的机制，构建更类人的体积记忆空间，其中信息更丰富，记忆单元间的连接更清晰、更显式。

**主要类型**：

##### Pyramid（金字塔结构）

此类将记忆构建为多级金字塔，信息逐步组织到更高抽象层，并以粗到细的方式查询。

**代表工作**：
- **HiAgent**（Hu et al., 2025a）：通过以子目标为中心的分层工作记忆管理长期任务，为当前活动子目标保持详细轨迹，同时将完成的子目标压缩为更高级摘要，可在需要时选择性检索
- **GraphRAG**（Edge et al., 2025）：通过社区检测构建多级图索引，递归将实体级子图聚合为社区级摘要
- **Zep**（Rasmussen et al., 2025）：将 Agent 记忆形式化为时间知识图谱，类似执行社区分区
- **ILM-TR**（Tang et al., 2024）：采用树形、金字塔索引，结合内循环机制，重复查询不同抽象级别的摘要并更新短期记忆缓冲区，直到检索证据和生成答案稳定
- **EMG-RAG**（Wang et al., 2024k）：为确保可控个性化，将可编辑记忆图组织为三层，其中树形类型和子类索引（L1, L2）位于实体级记忆图（L3）之上
- **G-Memory**（Zhang et al., 2025c）：在多 Agent 系统中，使用三层图层次结构（洞察图、查询图和交互图）构建共享经验。此设计使以查询为中心的遍历能够在高级跨试验洞察和具体协作的紧凑轨迹之间垂直移动

**技术实现**：
- **存储**：多级索引结构、层次化图
- **查询**：粗到细检索、跨层导航
- **压缩**：层次化摘要生成

**应用场景**：
- 长期任务规划
- 大规模知识组织
- 多级检索系统

<br>

##### Multi-Layer（多层结构）

这些形式强调分层专业化，将记忆组织为专注于特定信息类型或功能的不同模块或级别。

**代表工作**：
- **Lyfe Agents**（Kaiya et al., 2023）：将显著长期记录与低价值瞬态细节分离，允许系统维护紧凑、行为重要的记忆层
- **H-Mem**（Sun and Zeng, 2025）：显式将长期对话记忆安排为按语义抽象排序的多级层次，其中较低层存储细粒度交互片段，较高层存储越来越压缩的摘要
- **HippoRAG**（Gutierrez et al., 2024）：受生物学启发的架构，将记忆分解为关联索引组件（实现为开放知识图谱）和底层段落存储，使用图层编排存储内容上的多跳检索
- **HippoRAG 2**（Gutiérrez et al., 2025）：将此设计扩展到非参数持续学习设置，通过更深段落集成和在线 LLM 过滤丰富索引层
- **AriGraph**（Anokhin et al., 2024）：在统一图内按信息类型分离记忆，结合编码环境结构的语义知识图谱世界模型和将具体观察链接回语义骨干的事件级组件
- **SGMem**（Wu et al., 2025h）：在原始对话之上添加句子图记忆级别，在分块单元内将历史表示为句子级图
- **CAM**（Li et al., 2025f）：通过逐步将重叠语义图聚类为分层模式结构，对阅读过程本身进行分层

**技术实现**：
- **存储**：多层数据结构、专业化模块
- **查询**：跨层查询、专业化检索
- **协调**：层间信息流协调

**应用场景**：
- 复杂推理任务
- 多模态记忆整合
- 专业化记忆系统

<br>

**优势**：
- **多维协同**：通过将记忆节点置于层次和关系维度的交叉点，分层记忆允许不同记忆交互并形成多维协同
- **整体知识编码**：此设计帮助系统编码更整体、更深层上下文化的知识
- **强大检索**：支持复杂、多路径查询，在每层内通过关系网络移动，在层间跨抽象级别移动
- **高精度检索**：能够以高精度检索任务相关记忆，导致强任务性能

**劣势**：
- **结构复杂性**：结构的复杂性及其密集的信息组织为检索效率和整体有效性带来挑战
- **语义维护困难**：确保所有存储记忆保持语义意义仍然困难且关键
- **布局优化困难**：设计系统的最优三维布局仍然困难且关键
- **计算成本**：构建和查询成本高
  - 构建复杂度：$O(k \cdot |V|^2)$，其中 $k$ 是层数
  - 查询复杂度：$O(k \cdot (|V| + |E|))$ 对于简单查询

<br>

### 3.2 Parametric Memory（参数记忆）

#### 定义

与 Token-level Memory 不同，Token-level Memory 将信息存储为可见和可编辑的离散单元，**Parametric Memory 将信息直接存储在模型参数中**。在本节中，我们研究将记忆嵌入可学习参数空间的方法，允许模型内化和回忆信息，而无需引用外部存储。

形式化定义：
- 参数记忆：$\mathcal{M}\_{param} = \{\theta_i\}\_{i=1}^n$
  - $\theta_i \in \mathbb{R}^{d_i}$：参数向量
  - 记忆编码：$m \rightarrow \theta$，通过训练过程将记忆 $m$ 编码到参数 $\theta$
  - 记忆访问：$f\_{\theta}(x)$，通过前向计算隐式访问记忆

**核心特征**：
- **隐式存储**：信息通过参数空间的统计模式编码
- **隐式访问**：在前向计算过程中隐式访问
- **分布式表示**：记忆分布在参数空间中
- **泛化能力**：支持跨任务的泛化

基于记忆相对于核心模型参数的存储位置，我们区分两种主要形式的参数记忆：

**参数记忆的两种主要类型**：

1. **Internal Parametric Memory（内部参数记忆）**：记忆编码在模型的原始参数内（如权重、偏置）。这些方法直接调整基础模型以纳入新知识或行为。

2. **External Parametric Memory（外部参数记忆）**：记忆存储在额外或辅助参数集中，如适配器、LoRA 模块或轻量级代理模型。这些方法引入新参数来承载记忆，而不修改原始模型权重。

这种区别反映了一个关键设计选择：记忆是完全吸收到基础模型中，还是模块化地附加在其旁边。在以下小节中，对于每种形式，我们概述实现方法，分析其优势和局限性，并列出代表性系统或工作。

<br>

#### 3.2.1 Internal Parametric Memory（内部参数记忆）

**定义**：

内部参数记忆将领域知识、个性化知识或下游任务所需的先验注入模型。我们还将增强模型的长上下文能力视为注入先验。记忆注入的时机可以是预训练阶段、持续预训练阶段、中训练阶段或后训练阶段。存储在内部参数中的记忆不添加额外参数或额外模块。

形式化定义：
- 内部参数：$\theta\_{internal} = \theta\_{base} + \Delta\theta$
  - $\theta\_{base}$：基础模型参数
  - $\Delta\theta$：通过训练获得的参数更新
- 记忆注入：$m \rightarrow \Delta\theta$，通过训练过程将记忆 $m$ 编码为参数更新

**核心特征**：
- **直接修改**：直接调整基础模型参数
- **无额外参数**：不增加模型大小
- **完全融合**：记忆完全融合到模型中
- **更新困难**：更新需要重新训练

**主要方法**：

##### Pre-Train（预训练阶段）

一些工作在预训练阶段引入记忆机制，旨在解决长尾世界知识难以压缩到有限模型参数中的问题。

**代表工作**：
- **LMLM**（Zhao et al., 2025b）、**HierMemLM**（Pouransari et al., 2025）：在预训练阶段将知识检索的记忆存储在模型中，同时将知识本身存储在外部知识库中
- **Xiao et al.**（2024）、**Qin et al.**（2024b,c）、**Dao**（2024）、**Shah et al.**（2024）：优化注意力的计算效率以增强长窗口记忆能力

**技术实现**：
- **训练目标**：结合知识检索和记忆存储
- **架构修改**：优化注意力机制
- **外部知识库**：配合外部知识库使用

<br>

##### Mid-Train（中训练阶段）

在持续预训练阶段，一些工作整合来自下游任务的泛化经验。

**代表工作**：
- **Su et al.**（2025）、**Zhang et al.**（2025j）：整合 Agent 经验
- **Zaheer et al.**（2020）、**Chen et al.**（2024a）：在中训练阶段改进 LLM 的长窗口性能或效率，使模型能够在记忆辅助任务中通过更长窗口维护更多短期记忆

**技术实现**：
- **持续预训练**：在预训练基础上继续训练
- **任务经验整合**：将任务经验编码到参数中
- **长窗口优化**：优化长上下文处理能力

<br>

##### Post-Train（后训练阶段）

其他工作在后训练阶段整合记忆以适应下游任务。

**代表工作**：
- **Character-LM**（Shao et al., 2023）、**CharacterGLM**（Zhou et al., 2024a）：将 LLM 微调为不同特征
- **SELF-PARAM**（Wang et al., 2025n）：在后训练阶段通过 KL 散度蒸馏注入额外知识，无需额外参数
- **Room**（Kim et al., 2023b）：外部存储知识，内部保存经验
- **KnowledgeEditor**（Cao et al., 2021）：修改内部参数，旨在仅改变需要编辑的知识
- **MEND**（Mitchell et al., 2022）：通过使用小网络修改大模型的梯度实现快速知识编辑
- **PersonalityEdit**（Mao et al., 2024）：基于心理学人格理论提出 LLM 人格编辑数据集
- **APP**（Ma et al., 2024）：采用多个训练目标，确保在知识编辑期间相邻知识受到最小干扰
- **DINM**（Wang et al., 2024c）：提出模型编辑方法，使模型能够学习拒绝此类危险请求，而不影响其正常功能

**技术实现**：
- **微调**：全参数微调或部分参数微调
- **知识编辑**：精确修改特定知识
- **参数更新**：通过梯度更新参数

**应用场景**：
- 角色扮演
- 领域适应
- 知识更新

<br>

**优势**：
- **简单结构**：不向原始模型添加额外推理开销或部署成本
- **完全融合**：记忆完全融合到模型中
- **无额外成本**：推理时无额外计算成本

**劣势**：
- **更新困难**：存储新记忆需要重新训练，成本高且容易遗忘旧记忆
- **灾难性遗忘**：新知识可能覆盖旧知识
- **适用性限制**：更适合大规模存储领域知识或任务先验，而不是短段个性化记忆或工作记忆
  - 更新成本：$O(|\theta|)$，需要重新训练整个模型

<br>

#### 3.2.2 External Parametric Memory（外部参数记忆）

**定义**：

将记忆存储为 LLM 外部的 token 导致模型在输入窗口中对 token 形式记忆内容的理解不足。同时，将记忆存储在 LLM 参数中存在问题，如更新困难和与预训练知识冲突。一些工作采用折衷方法，通过外部参数引入记忆，而不改变 LLM 的原始参数。

形式化定义：
- 外部参数：$\theta\_{external} = \{\theta\_{adapter}, \theta\_{lora}, \theta\_{aux}\}$
  - $\theta\_{adapter}$：适配器参数
  - $\theta\_{lora}$：LoRA 参数
  - $\theta\_{aux}$：辅助模型参数
- 记忆编码：$m \rightarrow \theta\_{external}$，将记忆编码到外部参数中
- 模型输出：$f\_{\theta\_{base}, \theta\_{external}}(x)$，结合基础模型和外部参数

**核心特征**：
- **模块化**：记忆存储在独立模块中
- **可插拔**：可以添加、移除或替换
- **不修改基础模型**：保持基础模型参数不变
- **灵活更新**：支持模块化更新

**主要方法**：

##### Adapter（适配器）

外部参数记忆方法的常见路线依赖于附加到冻结基础模型的模块。

**代表工作**：
- **MLP-Memory**（Wei et al., 2025d）：通过 MLP 将 RAG 知识与 Transformer 解码器集成
- **K-Adapter**（Wang et al., 2021）：通过训练任务特定适配器模块注入新知识，同时保持原始骨干不变，实现持续知识扩展而不干扰预训练表示
- **WISE**（Wang et al., 2024e）：进一步引入双参数记忆设置——分离预训练知识和编辑知识——以及路由机制，在推理时动态选择使用哪个参数记忆，从而缓解终身编辑期间的冲突
- **ELDER**（Li et al., 2025d）：通过维护多个 LoRA 模块并学习基于输入语义自适应选择或混合它们的路由函数，推进这一方向，提高长期编辑场景中的稳健性和可扩展性

**技术实现**：
- **适配器架构**：在 Transformer 层间插入适配器
- **LoRA**：低秩适应，参数高效微调
- **路由机制**：动态选择或混合适配器

**应用场景**：
- 持续学习
- 多任务适应
- 知识编辑

<br>

##### Auxiliary LM（辅助语言模型）

除了基于适配器的存储，另一路线采用更架构解耦的外部参数记忆形式，其中记忆存储在单独模型或外部知识模块中。

**代表工作**：
- **MAC**（Tack et al., 2024）：通过摊销网络将新文档信息压缩为紧凑调制，并将其存储在记忆库中
- **Retroformer**（Yao et al., 2024a）：提出学习范式，用于记忆过去任务执行中成功或失败的经验

**技术实现**：
- **辅助模型**：独立的轻量级模型
- **记忆库**：外部存储结构
- **调制机制**：将记忆调制到主模型

**应用场景**：
- 文档记忆
- 经验积累
- 知识压缩

<br>

**优势**：
- **适应性与稳定性平衡**：在适应性和模型稳定性之间提供平衡
- **模块化更新**：可以添加、移除或替换，而不干扰基础模型的预训练表示空间
- **支持模块化更新**：支持模块化更新、任务特定个性化和受控回滚
- **避免灾难性遗忘**：避免可能在全模型微调中发生的灾难性遗忘或全局权重扭曲

**劣势**：
- **间接影响**：外部参数模块仍必须与模型内部表示流集成，意味着其影响是间接的，通过模型的注意力和计算路径介导
- **有效性依赖**：记忆注入的有效性取决于外部参数与内部参数知识接口的程度
- **额外开销**：需要额外的参数和计算
  - 参数开销：$O(|\theta\_{external}|)$
  - 计算开销：$O(|\theta\_{external}| \cdot |x|)$

<br>

### 3.3 Latent Memory（潜在记忆）

#### 定义

**Latent Memory** 指记忆隐式地承载在模型的内部表示中（如 KV cache、激活、隐藏状态、潜在嵌入），而不是存储为显式、人类可读的 token 或专用参数集。

形式化定义：
- 潜在记忆：$\mathcal{M}\_{latent} = \{h_i, \mathbf{K}_i, \mathbf{V}_i\}\_{i=1}^n$
  - $h_i \in \mathbb{R}^d$：隐藏状态
  - $\mathbf{K}_i, \mathbf{V}_i$：键值缓存
- 记忆形成：$m \rightarrow h$ 或 $m \rightarrow (\mathbf{K}, \mathbf{V})$，将记忆编码为潜在表示
- 记忆访问：通过前向计算隐式访问

**核心特征**：
- **隐式表示**：记忆以连续向量形式存在
- **低可读性**：不暴露为明文，提供隐私保护
- **低延迟**：引入的推理延迟较少
- **高信息密度**：在模型自身表示空间内保留细粒度上下文信号，可能提供更好的性能增益

如图 4 所示，我们按潜在记忆的**起源**组织现有工作，即潜在状态如何形成并引入 Agent。我们将这部分工作总结在表 3 中。

**潜在记忆的三大类型**：

1. **Generate（生成型）**：潜在记忆由独立模型或模块产生，然后作为可复用内部表示提供给 Agent。

2. **Reuse（复用型）**：潜在记忆直接从先前计算中携带，最突出的是 KV-cache 复用（轮次内或跨轮次），以及传播隐藏状态的循环或有状态控制器。

3. **Transform（转换型）**：现有潜在状态转换为新表示（如蒸馏、池化或压缩），使 Agent 能够保留要点，同时减少延迟和上下文占用。

<br>

#### 3.3.1 Generate（生成型）

**定义**：

主要工作路线通过生成新潜在表示而不是复用或转换现有激活来构建记忆。在此范式中，模型或辅助编码器创建紧凑连续状态。这些状态可能表现为序列中的特殊 token 或独立向量。它们总结来自长上下文、任务轨迹或多模态输入的基本信息。生成的潜在摘要然后被存储、插入或用作后续推理或决策的条件。这使系统能够在其原生上下文长度之外操作，维护任务特定中间状态，并在不重新访问原始输入的情况下跨片段保留知识。

形式化定义：
- 生成函数：$f\_{gen}: \mathcal{M}\_{input} \rightarrow \mathbf{h}\_{latent}$
  - $\mathcal{M}\_{input}$：输入记忆（长上下文、轨迹等）
  - $\mathbf{h}\_{latent} \in \mathbb{R}^d$：生成的潜在表示
- 记忆存储：$\mathcal{M}\_{latent}' = \mathcal{M}\_{latent} \cup \{\mathbf{h}\_{latent}\}$
- 记忆使用：作为条件或上下文注入后续推理

**核心特征**：
- **主动生成**：通过学习的编码或压缩显式产生记忆
- **紧凑表示**：生成高度信息密集的表示
- **可复用单元**：生成的潜在状态作为可复用记忆单元
- **任务定制**：针对任务定制的表示

虽然具体形式在不同研究中有所不同，但基本思想保持一致。记忆通过学习的编码或压缩显式产生，生成的潜在状态作为可复用记忆单元支持未来推理。

这种设计选择也可能与参数记忆产生潜在歧义，特别是因为许多方法依赖单独训练的模型来生成潜在表示。然而，在本章中，我们的分类基于记忆形式而非学习机制。关键的是，尽管这些方法通过学习的编码生成记忆，但产生的潜在表示是显式实例化并作为独立记忆单元复用的，而不是直接嵌入到模型参数或前向传递激活中。

**单模态场景**：

在单模态设置中，主要方法组专注于长上下文处理和语言建模，模型生成少量内部表示来替代长原始输入。

**代表工作**：
- **Gist**（Mu et al., 2023）：训练语言模型在处理长提示后产生一组 gist token
- **Luo et al.**（2024）：在每个块边界引入特殊哨兵 token，鼓励模型将局部语义聚合到该 token
- **SoftCoT**（Xu et al., 2025d）：从最后隐藏状态生成实例特定的 soft token
- **CARE**（Choi et al., 2025）：通过训练上下文评估器，将检索到的 RAG 文档压缩为紧凑记忆 token
- **AutoCompressor**（Chevalier et al., 2023）：将整个长文档编码为少量摘要向量，作为 soft prompt
- **MemoRAG**（Qian et al., 2025）：使用 LLM 产生紧凑隐藏状态记忆，捕获全局语义结构
- **MemoryLLM**（Wang et al., 2024j）：在模型潜在空间中嵌入一组专用记忆 token
- **M+**（Wang et al., 2025m）：扩展到跨层长期记忆架构
- **LM2**（Kang et al., 2025b）：在每个层引入矩阵形状的潜在记忆槽

**技术实现**：
- **生成方式**：$h\_{latent} = f\_{encoder}(\text{context})$
- **存储形式**：特殊 token、独立向量、矩阵槽
- **注入方式**：作为条件、作为上下文、作为 soft prompt

**多模态场景**：

在多模态设置中，生成型潜在记忆扩展到图像、音频和视频，将它们编码为紧凑潜在表示。

**代表工作**：
- **CoMem**（Wu et al., 2025d）：使用 VLM 将多模态知识压缩为一组嵌入，作为即插即用记忆
- **Wu et al.**（2025e）：将整个 GUI 交互轨迹压缩为固定长度嵌入，注入到 VLM 输入空间
- **Time-VLM**（Zhong et al., 2025）：将视频或交互流划分为补丁，为每个补丁生成潜在嵌入
- **Mezghani et al.**（2022）：学习状态编码器，将视觉观察映射到潜在空间，构建仅包含新颖观察的情景记忆
- **MemoryVLA**（Shi et al., 2025a）：维护感知-认知记忆库，将感知细节和高级语义存储为 transformer 隐藏状态
- **XMem**（Cheng and Schwing, 2022）：将每帧编码为键值潜在嵌入，组织为多阶段记忆，包括感知、工作和长期组件

**技术实现**：
- **多模态编码**：$\mathbf{h}\_{multimodal} = f\_{multimodal}(m\_{text}, m\_{image}, m\_{audio})$
- **跨模态对齐**：对齐不同模态的潜在空间
- **统一表示**：将多模态信息统一为单一潜在表示

**优势**：
- **高信息密度**：生成高度信息密集的表示，捕获关键动态、长程依赖或跨模态关系
- **避免重复处理**：避免重复处理完整上下文，实现跨扩展交互的更高效推理
- **任务定制**：可以主动构建针对任务的高度信息密集表示
- **最小存储成本**：以最小存储成本捕获信息

**劣势**：
- **信息损失**：生成过程本身可能引入信息损失或偏差
- **状态漂移**：状态可能在多次读写周期中漂移或累积错误
- **计算开销**：训练专用模块生成潜在表示引入额外计算开销、数据需求和工程复杂性
- **训练成本**：需要额外的训练数据和训练过程

<br>

#### 3.3.2 Reuse（复用型）

**定义**：

与生成新潜在表示的方法不同，另一条工作路线**直接复用模型的内部激活**，主要是键值（KV）cache，作为潜在记忆。这些方法不转换（修改、压缩）存储的 KV 对，而是将前向传递的原始激活视为可复用记忆条目。主要挑战是确定保留哪些 KV 对、如何索引它们，以及在长上下文或持续处理需求下如何高效检索它们。

形式化定义：
- KV cache 记忆：$\mathcal{M}\_{KV} = \{(\mathbf{K}_i, \mathbf{V}_i)\}\_{i=1}^n$
  - $\mathbf{K}_i, \mathbf{V}_i \in \mathbb{R}^{d \times l_i}$：键值缓存矩阵
  - $d$：隐藏维度
  - $l_i$：序列长度
- 记忆存储：$\mathcal{M}\_{KV}' = \mathcal{M}\_{KV} \cup \{(\mathbf{K}\_{new}, \mathbf{V}\_{new})\}$
- 记忆检索：$\mathcal{Q}\_{KNN}(q, k) = \text{TopK}(\{\text{sim}(q, \mathbf{K}_i)\}\_{i=1}^n)$
  - 使用 K 近邻搜索检索相关 KV 对

**核心特征**：
- **直接复用**：直接利用模型自身内部激活作为记忆
- **完整保真度**：保留模型内部激活的完整保真度
- **无信息损失**：不通过修剪或压缩丢失信息
- **概念简单**：概念简单，易于集成到现有形式

从认知角度，Gershman et al.（2025）通过将生物记忆框架为键值系统提供了概念基础，其中键作为检索地址，值编码存储内容——这一抽象与现代 LLM 中基于 KV 的记忆紧密对齐。

**代表工作**：
- **Memorizing Transformers**（Wu et al., 2022）：显式存储过去 KV 对，在推理期间通过 K 近邻搜索检索
- **FOT**（Tworkowski et al., 2023）：引入记忆注意力层，在推理期间对额外 KV 记忆执行基于 KNN 的检索
- **LONGMEM**（Wang et al., 2023b）：类似地增强长程检索，采用轻量级残差 SideNet，将历史 KV 嵌入视为持久记忆存储

**技术实现**：
- **KV cache 存储**：$\mathcal{M}\_{KV} = \{(\mathbf{K}_i, \mathbf{V}_i, \text{metadata}_i)\}\_{i=1}^n$
- **索引策略**：
  - 时间索引：$I\_{time}(t)$
  - 语义索引：$I\_{semantic}(\mathbf{q})$
  - 混合索引：$I\_{hybrid}(t, \mathbf{q})$
- **检索机制**：
  - KNN 搜索：$\text{TopK}(\{\text{sim}(\mathbf{q}, \mathbf{K}_i)\}\_{i=1}^n)$
  - 相似度计算：$\text{sim}(\mathbf{q}, \mathbf{K}_i) = \cos(\mathbf{q}, \text{mean}(\mathbf{K}_i))$

**应用场景**：
- **长上下文处理**：在长上下文场景中复用历史 KV cache
- **跨轮次记忆**：在对话系统中跨轮次复用 KV cache
- **持续学习**：在持续学习场景中保留和复用历史激活

**优势**：
- **完整保真度**：保留模型内部激活的完整保真度，确保不通过修剪或压缩丢失信息
- **概念简单**：概念简单，易于集成到现有形式
- **高度忠实**：高度忠实于模型的原始计算
- **无需训练**：不需要额外的训练过程

**劣势**：
- **存储开销**：原始 KV cache 随上下文长度快速增长，增加内存消耗
- **检索效率**：检索效率可能较低，特别是对于大规模 KV cache
- **索引挑战**：有效性严重依赖于索引策略
- **可扩展性**：对于极长上下文，存储和检索成本可能过高
  - 存储复杂度：$O(n \cdot d \cdot l)$，其中 $n$ 是记忆条目数，$d$ 是隐藏维度，$l$ 是序列长度

<br>

#### 3.3.3 Transform（转换型）

**定义**：

转换型潜在记忆方法专注于**修改、压缩或重构现有潜在状态**，而不是生成全新的或直接复用原始 KV cache。这些方法将 KV cache 和隐藏激活视为可塑记忆单元，通过选择、聚合或结构转换重塑它们。这样做，它们在概念上介于生成型和复用型记忆之间：模型不创建全新潜在表示，但也不仅仅重放存储的 KV 对。

形式化定义：
- 转换函数：$f\_{transform}: \mathcal{M}\_{raw} \rightarrow \mathcal{M}\_{compressed}$
  - $\mathcal{M}\_{raw} = \{(\mathbf{K}_i, \mathbf{V}_i)\}\_{i=1}^n$：原始 KV cache
  - $\mathcal{M}\_{compressed} = \{(\mathbf{K}'_j, \mathbf{V}'_j)\}\_{j=1}^m$：压缩后的 KV cache，$m < n$
- 压缩比：$\rho = \frac{m}{n} < 1$
- 信息保留：$\text{info\_retention} = \frac{\text{info}(\mathcal{M}\_{compressed})}{\text{info}(\mathcal{M}\_{raw})}$

**核心特征**：
- **选择性保留**：仅保留最重要的 KV 条目
- **信息压缩**：通过聚合或压缩减少存储需求
- **结构转换**：重塑潜在状态以提高效率
- **平衡保真度与效率**：在信息保真度和存储效率之间平衡

**主要工作路线**：

主要工作路线专注于压缩 KV cache，同时保留基本语义。一些方法通过仅保留最有影响的 token 来减少内存使用。

**代表工作**：
- **Scissorhands**（Liu et al., 2023b）：当缓存容量超过时，基于注意力分数修剪 token
- **SnapKV**（Li et al., 2024b）：通过头级投票机制聚合高重要性前缀 KV 表示
- **PyramidKV**（Cai et al., 2024）：跨层重新分配 KV 预算
- **SirLLM**（Yao et al., 2024b）：使用 token 熵准则估计 token 重要性，选择性保留仅信息丰富的 KV 条目
- **Memory3**（Yang et al., 2024a）：仅存储最关键的注意力键值对，显著缩小存储需求
- **RazorAttention**（Tang et al., 2025a）：引入更显式的压缩方案：计算每个头的有效注意力跨度，仅保留有限局部窗口，使用补偿 token 保留来自丢弃条目的信息
- **H2O**（Zhang et al., 2023）：采用更简单的驱逐策略，仅保留最近 token 以及特殊 H2 token 以减少内存占用

**技术实现**：
- **重要性评分**：
  - 注意力分数：$s_i = \sum\_{j} \alpha\_{ij}$，其中 $\alpha\_{ij}$ 是注意力权重
  - Token 熵：$H_i = -\sum\_{j} p\_{ij} \log p\_{ij}$
  - 综合评分：$score_i = \alpha \cdot s_i + \beta \cdot H_i$
- **选择策略**：
  - Top-K 选择：保留得分最高的 $k$ 个 token
  - 阈值选择：保留得分超过阈值 $\theta$ 的 token
  - 自适应选择：根据可用内存动态调整选择数量
- **压缩方法**：
  - 聚合：$\mathbf{K}' = \text{aggregate}(\{\mathbf{K}_i: i \in \text{selected}\})$
  - 池化：$\mathbf{K}' = \text{pool}(\mathbf{K}, \text{method})$
  - 蒸馏：$\mathbf{K}' = f\_{distill}(\mathbf{K})$

**应用场景**：
- **长上下文处理**：在长上下文场景中压缩 KV cache
- **内存受限环境**：在内存受限环境中减少存储需求
- **实时推理**：在实时推理场景中提高效率

**优势**：
- **紧凑表示**：产生更紧凑和信息密集的记忆表示
- **减少存储成本**：减少存储成本，实现长上下文的高效检索
- **信息密度**：通过重塑潜在状态，允许模型访问可能比原始激活更有用的蒸馏语义信号
- **效率提升**：使 LLM 能够扩展其可用上下文长度并提高推理性能，而无需依赖原始 cache 复用

**劣势**：
- **信息损失风险**：转换引入信息损失风险
- **可解释性降低**：压缩状态可能比直接复用的 KV cache 更难解释或验证
- **系统复杂性**：修剪、聚合或重新编码所需的额外计算增加系统复杂性
- **压缩质量依赖**：压缩质量严重依赖于重要性评分和选择策略
  - 压缩损失：$\text{loss}\_{compression} = \text{dist}(\mathcal{M}\_{raw}, \mathcal{M}\_{compressed})$

<br>

### 3.4 Adaptation（适配）

**定义**：

如上所述，大量工作专注于 Agent 记忆，清楚地表明记忆机制对 Agent 系统至关重要。Agent 系统中记忆类型的选择反映了设计者期望 Agent 在给定任务中的行为方式。设计者不仅要求 Agent 记住某些信息，还隐式表达他们希望这些信息如何塑造 Agent 的行为。因此，为任务选择正确的记忆类型远不止简单的组合选择。

在本节中，我们从每种记忆类型的特征开始，讨论在理想设置中它们最适合哪些任务和场景，如图 5 所示。我们希望这一讨论能够为做出实际选择提供有用的想法和指导。示例仅说明这些理想化设置中的一种可能记忆形式，并不意味着其他记忆类型在同一场景中缺乏独特优势。

形式化定义：
- 任务-记忆映射：$f\_{adapt}: \mathcal{T} \times \mathcal{C} \rightarrow \mathcal{M}\_{type}$
  - $\mathcal{T}$：任务空间
  - $\mathcal{C}$：约束条件（计算资源、隐私要求等）
  - $\mathcal{M}\_{type} \in \{\text{Token}, \text{Parametric}, \text{Latent}\}$：记忆类型

<br>

#### Token-level Memory 的适配场景

**核心特征**：

Token-level Memory 保持符号性、可寻址性和透明性，使其特别适合**显式推理、可控性和可问责性**至关重要的场景。这种记忆类型在实时、高频更新设置中表现出色，其中 Agent 必须持续跟踪和修订信息，知识本身表现出可以显式建模的清晰结构。其外部化能力允许记忆易于检查、审计、传输或修订，使其特别适合需要精确添加/删除/更新操作的领域。高水平的可解释性进一步确保 Agent 的决策过程可以追溯到具体记忆单元，这是高风险应用中的关键属性。此外，Token-level Memory 提供长期稳定性并避免灾难性遗忘，使 Agent 能够在扩展时间范围内积累可靠知识。另一个实际优势是 Token-level Memory 通常作为即插即用模块实现，允许它轻松与最新的闭源或开源基础模型集成，而无需修改其内部参数。

**适用场景**：

- **聊天机器人和多轮对话系统**：需要维护对话历史和用户偏好
  - 代表工作：MemoryBank（Zhong et al., 2024）、MemGPT（Packer et al., 2023a）、Mem0（Chhikara et al., 2025）
  
- **长期或终身 Agent**：需要稳定记忆
  - 代表工作：AI Persona（Wang et al., 2024f）、Westhäußer et al.（2025）
  
- **用户特定个性化画像**：需要精确的用户偏好和特征存储
  - 代表工作：MemoryBank（Zhong et al., 2024）、MPC（Lee et al., 2023）
  
- **推荐系统**：需要用户偏好和交互历史
  - 代表工作：RecMind（Wang et al., 2024h）、InteRecAgent（Huang et al., 2025d）、Memocrs（Xi et al., 2024a）
  
- **企业或组织知识库**：需要结构化、可审计的知识存储
  
- **法律、合规和其他高风险领域**：需要可验证来源和可解释决策

**形式化表示**：
- 记忆操作：$\mathcal{M}\_{token}' = \text{CRUD}(\mathcal{M}\_{token}, \text{operation})$
- 可追溯性：$\text{trace}(a_t) = \{m_i: m_i \in \text{retrieved}(a_t)\}$
- 稳定性：$\text{stability}(\mathcal{M}\_{token}) = 1 - \text{forgetting\_rate}$

<br>

#### Parametric Memory 的适配场景

**核心特征**：

与符号记忆相比，Parametric Memory 是**隐式、抽象和可泛化的**，使其自然适合需要概念理解和广泛模式归纳的任务。当 Agent 必须依赖适用于不同上下文的通用知识或规则时，它特别有效，因为这种规律性可以内化为分布式表示，而无需显式外部查找。这种内化支持流畅推理和端到端处理，使模型能够系统地泛化到未见任务或问题变体。因此，Parametric Memory 更适合需要结构洞察、稳健抽象和深度内化的行为或风格模式的任务。

**适用场景**：

- **角色扮演或角色一致行为**：需要维持一致的角色特征和风格
  - 代表工作：Character-LM（Shao et al., 2023）、CharacterGLM（Zhou et al., 2024a）
  
- **数学推理、编码、游戏和结构化问题解决**：需要深度抽象和模式识别
  
- **人类对齐和规范行为先验**：需要内化的行为准则
  
- **风格化、专业或领域专家响应**：需要特定领域的知识内化
  - 代表工作：KnowledgeEditor（Cao et al., 2021）、MEND（Mitchell et al., 2022）

**形式化表示**：
- 内化过程：$m \rightarrow \theta$，通过训练将记忆编码到参数
- 泛化能力：$f\_{\theta}(x\_{new}) = f\_{\theta}(x\_{train})$，对于相似输入
- 抽象表示：$\text{abstract}(m) = \text{pattern}(\theta)$

<br>

#### Latent Memory 的适配场景

**核心特征**：

与 Token-level 或 Parametric Memory 不同，Latent Memory 位于显式数据和固定模型权重之间，实现**灵活性和效率的独特平衡**。其低可读性提供内在隐私保护，使潜在表示适合敏感信息处理。同时，其高表达能力允许以最小信息损失进行丰富语义编码，使 Agent 能够捕获跨模态或任务的微妙相关性。Latent Memory 还支持高效的推理时检索和集成，使 Agent 能够注入大量紧凑知识。因此，这种记忆类型优先考虑性能和可扩展性而非可解释性，实现高知识密度和压缩，非常适合受限或高度动态的环境。

**适用场景**：

- **多模态或完全集成的 Agent 架构**：需要跨模态的统一表示
  - 代表工作：MemoryVLA（Shi et al., 2025a）、XMem（Cheng and Schwing, 2022）、CoMem（Wu et al., 2025d）
  
- **设备上或边缘部署和云服务环境**：需要高效的记忆表示和检索
  
- **加密或隐私敏感应用领域**：需要保护敏感信息
  - 代表工作：各种基于潜在表示的隐私保护系统

**形式化表示**：
- 隐私保护：$\text{privacy}(\mathbf{h}\_{latent}) > \text{privacy}(m\_{token})$
- 信息密度：$\text{density}(\mathbf{h}\_{latent}) = \frac{\text{info}(\mathbf{h})}{|\mathbf{h}|}$
- 效率：$\text{efficiency} = \frac{\text{performance}}{\text{storage\_cost}}$

<br>

#### 记忆形式选择指南

**决策框架**：

选择记忆形式时，考虑以下维度：

1. **可解释性要求**：
   - 高可解释性 → Token-level Memory
   - 低可解释性 → Parametric/Latent Memory

2. **更新频率**：
   - 高频更新 → Token-level Memory
   - 低频更新 → Parametric Memory

3. **存储效率**：
   - 高存储效率 → Latent Memory
   - 中等存储效率 → Parametric Memory
   - 低存储效率 → Token-level Memory

4. **隐私要求**：
   - 高隐私要求 → Latent Memory
   - 低隐私要求 → Token-level Memory

5. **任务类型**：
   - 需要显式推理 → Token-level Memory
   - 需要模式泛化 → Parametric Memory
   - 需要高效处理 → Latent Memory

**混合方案**：

在实践中，许多系统采用**混合记忆架构**，结合多种记忆形式的优势：

- **Token + Latent**：使用 Token-level Memory 存储可解释信息，使用 Latent Memory 存储高效表示
- **Parametric + Token**：使用 Parametric Memory 存储通用知识，使用 Token-level Memory 存储特定信息
- **三层架构**：结合 Token-level、Parametric 和 Latent Memory，在不同层次使用不同形式

**形式化表示**：
- 混合记忆：$\mathcal{M}\_{hybrid} = \{\mathcal{M}\_{token}, \mathcal{M}\_{param}, \mathcal{M}\_{latent}\}$
- 路由函数：$r: \text{query} \rightarrow \mathcal{M}\_{type}$，根据查询选择记忆类型
- 融合函数：$f\_{fusion}: \{\mathcal{M}\_{type}\} \rightarrow \text{context}$，融合不同记忆类型的结果

<br>

## 4. Functions
<br>

### 核心问题

从大语言模型作为通用、无状态的文本处理器，到自主、目标导向的智能体，不仅是渐进式改进，更是**范式转变**。这一转变暴露了无状态性的关键局限。

**核心观点**：智能体必须能够**持久化、适应、并在时间上连贯地交互**。实现这一点不仅依赖大上下文窗口，更根本地依赖于**记忆能力**。

<br>

### 记忆功能分类体系

基于时间维度，记忆系统分为两大类：

1. **长期记忆（Long-term Memory）**：持久、跨会话的知识积累存储
2. **短期记忆（Short-term Memory）**：瞬态、会话内的工作空间，用于主动推理

进一步细分为三个主要功能支柱：

#### 1. Factual Memory（事实记忆，4.1节）

**功能**：智能体的**陈述性知识库**，确保一致性、连贯性和适应性

**回答的问题**："智能体知道什么？"

**包含内容**：
- 明确的事实
- 用户偏好
- 环境状态

#### 2. Experiential Memory（经验记忆，4.2节）

**功能**：智能体的**程序和策略知识**，通过从历史轨迹、失败和成功中抽象而来

**回答的问题**："智能体如何改进？"

**包含内容**：
- 持续学习能力
- 自我进化机制

#### 3. Working Memory（工作记忆，4.3节）

**功能**：容量受限、动态控制的**临时工作区**，用于单个任务或会话期间的主动上下文管理

**回答的问题**："智能体现在在思考什么？"

**包含内容**：
- 当前任务状态
- 活跃推理上下文

<br>

### 记忆系统的认知循环

这三个记忆系统并非孤立，而是形成**动态、相互连接的架构**，定义了智能体的认知循环：

1. **编码（Encoding）**：将交互结果（新获得的事实、失败计划的结果）通过总结、反思或抽象，整合到长期记忆中
2. **处理（Processing）**：在工作记忆中发生，作为即时推理的活跃工作空间
3. **检索（Retrieval）**：从持久存储的事实记忆和经验记忆中提取相关上下文和技能，填充工作空间

**编码-处理-检索**序列构成了使智能体能够同时从过去学习和在现在推理的核心架构模式。



<br>

### 4.1 Factual Memory（事实记忆）

<br>

#### 定义与功能

**Factual Memory** 指智能体存储和检索关于过去事件、用户特定信息和外部环境状态的**明确、陈述性事实**的能力。

**功能目标**：
- **一致性（Consistency）**：稳定行为和自我呈现，避免矛盾和立场随意变化
- **连贯性（Coherence）**：强大的上下文感知，能够回忆和整合相关交互历史
- **适应性（Adaptability）**：基于存储的用户档案和历史反馈个性化行为

<br>

#### 认知科学基础

借鉴认知科学中的**陈述性记忆（Declarative Memory）**框架：

- **情景记忆（Episodic Memory）**：存储个人经历的事件，关联特定时间和空间上下文（what, where, when）
- **语义记忆（Semantic Memory）**：保留一般事实知识、概念和词义，独立于获得它们的特定场合

在智能体系统中，这种生物学区分被操作化为**处理连续体**而非严格二分：

1. **初始阶段**：记录具体交互历史作为情景痕迹（对话轮次、用户动作、环境状态）
2. **后续处理**：应用总结、反思、实体提取和事实归纳
3. **结果存储**：存储在向量数据库、键值存储或知识图谱中，通过去重和一致性检查程序管理

通过这一序列，原始事件流逐渐转化为可重用的语义事实库。

<br>

#### 分类体系

根据主要实体，事实记忆分为两类：

##### 4.1.1 User Factual Memory（用户事实记忆）

**定义**：跨会话和任务持久化关于特定用户的**可验证事实**

**包含内容**：
- 身份信息
- 稳定偏好
- 日常习惯
- 历史承诺
- 重要事件

**主要功能**：防止无状态交互的特征性失败模式
- **指代漂移（Coreference Drift）**：避免后续对话中无法追踪之前的指代
- **重复询问（Repeated Elicitation）**：避免反复询问已告知的信息
- **矛盾响应（Contradictory Responses）**：避免给出与之前承诺矛盾的答案

**工程实践**：
1. **选择与压缩**：从大量交互中筛选高价值信息
2. **结构化组织**：将信息组织为可检索的结构
3. **检索与重用**：在后续交互中高效检索相关事实
4. **一致性治理**：确保记忆的一致性和准确性

<br>

**实现策略**：

**对话连贯性（Dialogue Coherence）**

- **启发式选择**：选择性保留和排序交互历史
  - 按相关性、新近性、重要性或独特性排序
  - 过滤检索基于这些分数
  - 高价值项目被保留并定期压缩为更高级别的摘要

- **语义抽象**：将原始对话片段转换为高级语义表示
  - **Think in Memory**（Liu et al., 2023a）：将原始交互痕迹转换为思想表示
  - **Reflective Memory Management**（Tan et al., 2025c）：通过迭代更新操作转换为反思
  - **COMEDY**（Chen et al., 2025c）：生成、压缩和重用记忆，同时更新紧凑的用户档案

**目标一致性（Goal Consistency）**

- **任务状态跟踪**：动态跟踪和更新任务状态
  - **RecurrentGPT**（Zhou et al., 2023b）：保留确认信息，突出未解决元素
  - **Memolet**（Yen and Zhao, 2024）：维护任务上下文
  - **MemGuide**（Du et al., 2025b）：基于任务意图引导检索

- **复杂任务组织**：为复杂、长期任务构建结构化记忆
  - **A-Mem**（Xu et al., 2025c）：将记忆组织为相互连接的链接笔记图
  - **H-Mem**（Limbacher and Legenstein, 2020）：使用关联机制回忆先决条件事实

**具身场景应用**

- **M3-Agent**（Long et al., 2025）：持久化家庭成员、物体位置和日常习惯数据
- **MEMENTO**（Kwon et al., 2025）：重用信息以最小化冗余探索和重复指令
- **Encode-Store-Retrieve**（Shen et al., 2024）：将自我中心视觉流处理为文本可寻址条目

<br>

##### 4.1.2 Environment Factual Memory（环境事实记忆）

**定义**：关于用户外部实体的记忆，包括长文档、代码库、工具和其他智能体的交互痕迹

**主要功能**：
- 解决**不完整的事实回忆**和**不可验证的来源**
- 最小化多智能体协作中的**矛盾和冗余**
- 稳定异构环境中的**长期任务**

**核心目标**：提供可更新、可检索、可治理的外部事实层，跨会话和阶段提供稳定参考

<br>

**实现维度**：

**知识持久化（Knowledge Persistence）**

- **知识组织**：
  - **HippoRAG**（Gutierrez et al., 2024）：使用知识图谱促进证据传播
  - **MemTree**（Rezazadeh et al., 2025c）：采用动态层次结构优化聚合和目标访问

- **存储形式**：
  - **LMLM**（Zhao et al., 2025b）：将事实知识从模型权重中解耦，外部化到数据库，支持直接知识编辑和来源验证
  - **CALYPSO**（Zhu et al., 2023）：将冗长的游戏上下文提炼为易于理解的散文

- **参数中心方法**（持续知识更新）：
  - **MEMORYLLM**（Wang et al., 2024j）：整合可训练记忆池
  - **M+**（Wang et al., 2025m）：侧网络吸收新信息
  - **WISE**（Wang et al., 2024e）：专注于模型编辑挑战，允许适应动态环境并纠正过时事实

**共享访问（Shared Access）**

- **多智能体协作**：
  - **Memory Sharing**（Gao and Zhang, 2024b）：维护过去查询和响应的集中存储库，使智能体能够异步访问和构建同行的累积见解
  - **MetaGPT**（Hong et al., 2024）：使用共享消息池作为发布计划和部分结果的中央工作空间
  - **GameGPT**（Chen et al., 2023b）：类似的消息池机制
  - **G-Memory**（Zhang et al., 2025e）：采用层次记忆图作为统一协调媒介

- **社交模拟**：
  - **Generative Agents**（Park et al., 2023）：将全局环境和公共交互日志建模为共享记忆基质
  - **S3**（Gao et al., 2023a）：类似方法
  - **OASIS**（Yang et al., 2025）：大规模模拟器
  - **AgentSociety**（Piao et al., 2025）：支持大规模连贯、历史感知的社交动态

<br>

**总结**：环境事实记忆提供了持续可更新、可审计、可重用的外部事实层。在知识轴上，通过结构化组织和长期记忆模块提高事实回忆的完整性、可解释性和可编辑性。在协作轴上，通过共享和治理维护跨智能体和跨阶段的一致性，从而在长期、多参与者和多源信息下实现稳健的决策和执行。

<br>



### 4.2 Experiential Memory（经验记忆）

<br>

#### 定义与功能

**Experiential Memory** 封装了智能体将历史轨迹、提炼的策略和交互结果编码为**持久、可检索表示**的机制。

**与工作记忆的区别**：
- **工作记忆**：管理瞬态上下文
- **经验记忆**：专注于**跨不同情节的长期知识积累和转移**

<br>

#### 理论基础

**认知科学基础**：对应人类的**非陈述性记忆**，特别是程序和习惯系统

**生物学 vs 智能体实现**：
- **生物系统**：依赖分布式神经回路进行隐式技能获取
- **智能体系统**：通常使用**显式数据结构**（向量数据库、符号日志）

**智能体优势**：能够**内省、编辑和推理**自己的程序知识（生物系统不具备）

<br>

#### 核心价值

**持续学习和自我进化**的基础：

- **非参数适应路径**：避免频繁参数更新的高昂成本
- **学习闭环**：将交互反馈转化为可重用知识
- **能力提升**：
  - 纠正过去错误
  - 抽象可泛化的启发式
  - 编译例行行为
  - 最小化冗余计算
  - 随时间改进决策

<br>

#### 分类体系（基于抽象级别）

根据存储信息的抽象级别，经验记忆分为三类：

##### 4.2.1 Case-based Memory（基于案例的记忆）

**定义**：存储**最小处理的历史事件记录**，优先考虑高信息保真度以支持直接重放和模仿

**特点**：
- 避免广泛抽象
- 保留**情况与解决方案之间的原始对齐**
- 作为**具体、可验证证据的存储库**，作为证据驱动学习的上下文示例

<br>

**子类别**：

**轨迹（Trajectories）**

- **Memento**（Zhou et al., 2025a）：在文本环境中使用软Q学习动态优化选择高效用过去轨迹的概率
- **JARVIS-1**（Wang et al., 2025p）：在Minecraft中存储生存经验
- **EvoVLA**（Liu et al., 2025h）：保留视觉上下文
- **Auto-scaling Continuous Memory**（Wu et al., 2025e）：将GUI历史压缩为连续嵌入
- **早期经验范式**（Zhang et al., 2025j）：构建无奖励、智能体生成的交互痕迹，通过中期训练整合到模型参数中

**解决方案（Solutions）**

- **ExpeL**（Zhao et al., 2024）：自主收集经验，存储成功轨迹作为示例，同时提取文本见解指导未来行动
- **Synapse**（Zheng et al., 2024a）：注入抽象的状态-动作情节作为上下文示例
- **MapCoder**（Islam et al., 2024）：在程序合成中保留相关示例代码作为类似剧本的案例
- **FinCon**（Yu et al., 2024）：在金融领域维护过去行动、PnL轨迹和信念更新的情节记忆

<br>

**总结**：基于案例的记忆提供高信息保真度，提供可验证的证据用于模仿。然而，对原始数据的依赖在检索效率和上下文窗口消耗方面带来挑战。与可执行技能或抽象策略不同，案例不包含编排逻辑或函数接口，而是作为高级推理操作的事实基础。

<br>

##### 4.2.2 Strategy-based Memory（基于策略的记忆）

**定义**：提取**可转移的行动知识**，包括可重用的推理模式、任务分解、见解、抽象和跨情境工作流

**特点**：
- 将经验提升为**可编辑、可审计、可组合的高级知识**
- 减少对冗长轨迹重放的依赖
- 提高**跨任务泛化**和效率

**注意**：本节关注**非代码或弱代码基础的模板和工作流**；可执行函数、API、MCP协议和代码片段归类到4.2.3节

<br>

**子类别**（基于粒度和结构复杂性）：

**见解（Insights）**

- **H2R**（Ye et al., 2025b）：明确解耦规划级和执行级记忆，使高级规划见解和低级操作规则能够分别检索
- **R2D2**（Huang et al., 2025c）：整合记忆、反思和动态决策，从失败和成功案例中得出纠正见解
- **BrowserAgent**（Yu et al., 2025d）：在长期网络自动化中，将关键结论作为显式记忆持久化，稳定扩展的推理链并减轻上下文漂移

**工作流（Workflows）**

- **Agent Workflow Memory (AWM)**（Wang et al., 2024l）：在Mind2Web和WebArena上归纳可重用工作流，用作高级脚手架指导后续生成
- **Agent KB**（Tang et al., 2025d）：建立统一知识库，将工作流视为可转移的程序知识，采用层次检索，首先访问工作流以构建战略方法

**模式（Patterns）**

- **Buffer of Thoughts**（Yang et al., 2024b）：维护思维模板的元缓冲区，检索并实例化以解决新问题
- **ReasoningBank**（Ouyang et al., 2025）：将成功和失败抽象为可重用的推理单元
- **RecMind**（Wang et al., 2024h）：自我启发规划算法，生成中间自我指导以构建后续规划和工具使用
- **PRINCIPLES**（Kim et al., 2025a）：通过离线自我对弈构建合成策略记忆，在推理时指导策略规划

<br>

**总结**：基于策略的记忆（包括见解、工作流和模式）作为高级脚手架指导生成推理。与依赖检索特定、可能嘈杂或上下文相关的原始轨迹的基于案例的记忆不同，这种形式的记忆提炼可泛化的模式，有效约束搜索空间并提高在未见任务上的稳健性。关键区别是这些策略作为结构指导而非可执行行动；它们指导规划过程但不直接与环境交互。这一限制需要4.2.3节讨论的基于技能的记忆，它存储可调用能力和工具。最终，稳健的智能体通常协同这些组件：策略提供抽象规划逻辑，而技能处理接地执行。

<br>

##### 4.2.3 Skill-based Memory（基于技能的记忆）

**定义**：捕获智能体的**程序能力**，将抽象策略操作化为可验证的行动

**功能**：
- 编码**智能体能做什么**
- 补充关于智能体知道什么的陈述性知识
- 通过提供可调用、可测试、可组合的可执行文件，锚定感知-推理-行动循环

**证据**：语言模型可以学习何时以及如何调用工具，并可靠地扩展到大型工具库

<br>

**技能记忆的连续体**：

从内部、细粒度代码到外部化、标准化接口。统一标准：
- 技能必须**可由智能体调用**
- 结果必须**可验证**以支持学习
- 必须能够**与其他技能组合**形成更大的例程

<br>

**子类别**：

**代码片段（Code Snippets）**

- **Voyager**（Wang et al., 2024b）：不断增长的技能库，将成功的子轨迹提炼为可解释的程序
- **Darwin Gödel Machine**（Zhang et al., 2025h）：在经验验证下安全重写自己的代码，产生自我引用和逐步更有能力的技能集

**函数和脚本（Functions and Scripts）**

- **自主工具创建**（Qian et al., 2023; Yuan et al., 2024a）：使智能体能够自主创建专门工具
- **跨域精炼**（Fang et al., 2025d; Zheng et al., 2025a; Bouzenia et al., 2024）：通过演示和环境反馈在移动GUI、网络导航和软件工程等不同领域精炼工具使用能力
- **程序记忆机制**（Liu et al., 2025a; Han et al., 2025a）：将执行轨迹提炼为可检索脚本，促进高效泛化到新场景

**API（应用程序接口）**

- **早期工作**：微调模型以正确调用工具（Schick et al., 2023; Patil et al., 2024）
- **当前挑战**：API库的指数增长将主要瓶颈转移到检索
- **解决方案**：
  - **学习基础检索和重排序**（Zheng et al., 2024b; Gao and Zhang, 2024c; Qu et al., 2024, 2025a）：考虑工具文档质量、层次关系和协作使用模式
  - **功能语义捕获**（Shi et al., 2025c）：标准信息检索方法往往无法捕获工具的功能语义

**MCP（Model Context Protocol）**

- **目标**：减少基于API的生态系统中的协议碎片化
- **功能**：提供开放标准，统一智能体如何发现和使用工具和数据
- **特点**：包括按需加载工具和减少上下文开销的代码执行模式
- **支持**：广泛的平台支持表明向通用接口层的趋同

**前沿探索**：

- **可学习工具能力记忆**：处理不确定的神经工具
- **参数集成**：嵌入工具符号以统一检索和调用
- **架构即技能**：专门智能体作为模块化设计空间中的可调用模块（Xiao et al., 2025b; Wang et al., 2025i; Zhao et al., 2025a）

<br>

**总结**：基于技能的记忆构成智能体的活跃执行基础，从静态代码片段和模块化脚本演变为标准化API和可学习架构。它通过将基于案例和基于策略的记忆中的见解操作化为可验证程序，弥合抽象规划与环境交互之间的差距。随着工具创建、检索和互操作性机制（如MCP）的成熟，技能记忆超越了简单存储，实现了能力合成、精炼和执行的持续循环，推动开放端智能体进化。

<br>

##### 4.2.4 Hybrid Memory（混合记忆）

**定义**：集成多种形式的经验记忆的架构设计，平衡接地证据与可泛化逻辑

**优势**：通过维护从原始情节到提炼规则再到可执行技能的**知识谱**，动态选择最合适的记忆格式，确保检索精度和跨上下文的广泛泛化

<br>

**实现策略**：

**案例与策略结合**

- **ExpeL**（Zhao et al., 2024）：协同具体轨迹与抽象文本见解，使智能体能够回忆特定解决方案同时应用一般启发式
- **Agent KB**（Tang et al., 2025d）：采用层次结构，高级工作流指导规划，特定解决方案路径提供执行细节
- **R2D2**（Huang et al., 2025c）：整合历史痕迹的重放缓冲区与从过去错误中精炼决策策略的反思机制
- **Dynamic Cheatsheet**（Suzgun et al., 2025）：存储累积策略和问题解决见解，在推理时立即重用，防止冗余计算

**统一生命周期**

- **ChemAgent**（Tang et al., 2025c）：在科学推理中构建自更新库，配对执行案例与可分解技能模块
- **LARP**（Yan et al., 2023）：为开放世界游戏建立认知架构，协调世界知识的语义记忆、交互案例的情节记忆和可学习技能的程序记忆
- **G-Memory**（Zhang et al., 2025c）：进化系统，重复成功的案例逐渐编译为高效技能
- **Memp**（Fang et al., 2025d）：自动化从重检索到快速执行的转变
- **MemVerse**（Liu et al., 2025d）：结合参数记忆和令牌级程序记忆

<br>



### 4.3 Working Memory（工作记忆）

<br>

#### 定义与理论基础

**认知科学定义**：容量受限、动态控制的机制，通过选择、维护和转换任务相关信息来支持高级认知

**关键特征**：
- 不仅仅是临时存储
- 意味着**资源约束下的主动控制**
- 基于多组件模型和嵌入式过程账户，强调注意力焦点、干扰控制和有限容量

<br>

#### LLM中的工作记忆问题

**标准上下文窗口的局限**：
- 主要作为**被动、只读缓冲区**
- 模型可以在推理期间消耗窗口内容，但**缺乏明确机制**来动态选择、维持或转换当前工作空间

**行为证据**：当前模型**不表现出类人工作记忆特征**，强调需要明确设计的、可操作的工作记忆机制

<br>

#### 智能体工作记忆定义

**定义**：在单个情节内**主动管理和操作上下文**的机制集合

**目标**：将上下文窗口从被动缓冲区转变为**可控、可更新、抗干扰的工作空间**

**优势**：
- 在固定注意力预算下增加任务相关信息密度
- 抑制冗余和噪声
- 启用表示的重写或压缩以保持连贯的思维链

<br>

#### 分类体系（基于交互动力学）

##### 4.3.1 Single-turn Working Memory（单轮工作记忆）

**定义**：专注于**输入压缩和抽象**

**挑战**：在单次前向传递中处理大量即时输入
- 长文档（Chevalier et al., 2023）
- 高维多模态流（Wang et al., 2024g）

**目标**：动态过滤和重写证据，构建有界计算暂存器，最大化每个令牌的有效信息负载

<br>

**实现机制**：

**输入压缩（Input Condensation）**

目标：预处理上下文以最小化令牌使用，同时保留基本信息（Jiang et al., 2023）

**三种范式**（Liao et al., 2025a）：

1. **硬压缩（Hard Condensation）**
   - 基于重要性指标离散选择令牌
   - **LLMLingua**（Jiang et al., 2023）：估计令牌困惑度以丢弃可预测或任务无关内容
   - **LongLLMLingua**（Jiang et al., 2024）：扩展版本
   - **CompAct**（Yoon et al., 2024）：采用迭代策略保留最大化信息增益的段
   - **缺点**：硬选择可能切断语法或语义依赖

2. **软压缩（Soft Condensation）**
   - 将可变长度上下文编码为密集潜在向量（记忆槽）
   - **Gist**（Mu et al., 2023）：训练模型将提示压缩为有效摘要令牌
   - **In-Context Autoencoder (ICAE)**（Ge et al., 2024）：类似方法
   - **AutoCompressors**（Chevalier et al., 2023）：压缩为不同记忆嵌入
   - **优点**：高压缩比
   - **缺点**：需要额外训练，可能模糊细粒度细节

3. **混合方法（Hybrid）**
   - **HyCo2**（Liao et al., 2025a）：结合全局语义适配器（软）与令牌级保留概率（硬），试图调和这些权衡

**观察抽象（Observation Abstraction）**

目标：将原始观察转换为结构化格式，促进推理

- **复杂交互环境**：
  - **Synapse**（Zheng et al., 2024a）：将非结构化HTML DOM树重写为任务相关状态摘要
- **多模态设置**：
  - **Context as Memory**（Yu et al., 2025b）：基于视野重叠过滤帧
  - **VideoAgent**（Wang et al., 2024g）：将流转换为时间事件描述
  - **MA-LMM**（He et al., 2024）：维护视觉特征库

**效果**：将高维、冗余流重写为低维、语义丰富的表示，可在有限上下文窗口内高效处理

<br>

**总结**：单轮工作记忆作为主动压缩层，最大化上下文窗口对即时推理的效用。通过采用输入压缩和观察抽象，这些机制有效增加操作工作空间的信息密度，确保在容量约束下保留关键证据。然而，这种优化严格是**轮内**的；它解决静态输入的广度和复杂性，而不是动态交互的时间连续性。

<br>

##### 4.3.2 Multi-turn Working Memory（多轮工作记忆）

**定义**：解决与单轮设置根本不同的问题空间

**挑战**：在长期交互中，主要瓶颈从即时上下文容量转移到**任务状态和历史相关性的持续维护**

**问题**：即使扩展上下文窗口，历史的积累也必然：
- 饱和注意力预算
- 增加延迟
- 诱导目标漂移（Lu et al., 2025b）

**解决方案**：在多轮设置中，工作记忆作为**外部化状态载体**，组织读取、评估和写入的连续循环

**目标**：在有限资源预算内保持关键状态信息可访问和一致

<br>

**实现机制**（基于状态管理策略）：

**状态整合（State Consolidation）**

- **MemAgent**（Yu et al., 2025a）：使用循环机制更新固定预算记忆并丢弃冗余
- **MemSearcher**（Yuan et al., 2025a）：类似方法
- **ReSum**（Wu et al., 2025f）：定期将历史提炼为推理状态，利用强化学习优化摘要条件行为
- **ACON**（Kang et al., 2025c）：将状态整合框架为优化问题，联合压缩环境观察和交互历史为有界压缩，从失败案例迭代精炼压缩指南
- **IterResearch**（Chen et al., 2025a）：采用MDP启发的公式，迭代工作空间重建，演化报告作为持久记忆，定期合成减轻上下文窒息和噪声污染

**状态表示**：
- **MEM1**（Zhou et al., 2025b）：维护合并新观察与先前记忆的共享内部状态
- **MemGen**（Zhang et al., 2025d）：将潜在记忆令牌直接注入推理流（区别于显式文本）

**层次折叠（Hierarchical Folding）**

- **策略**：基于子目标分解任务轨迹，仅在子任务活跃时维护细粒度痕迹，子轨迹完成后将完成的子轨迹折叠为简洁摘要
- **优势**：允许工作记忆动态扩展和收缩
- **实现**：
  - **HiAgent**（Hu et al., 2025a）：使用子目标作为记忆单元，仅保留活跃动作-观察对，子目标完成后写回摘要
  - **Context-Folding**（Zhang et al., 2025q）：使折叠操作成为可学习策略
  - **AgentFold**（Ye et al., 2025a）：训练智能体自主确定何时分支到子轨迹以及如何将它们抽象为高级状态
  - **DeepAgent**（Li et al., 2025h）：应用于工具使用推理，将交互压缩为结构化情节和工作记忆，支持细粒度信用分配

**认知规划（Cognitive Planning）**

- **最高抽象级别**：工作记忆创建和维护外部化计划或世界模型
- **状态功能**：不仅仅是过去的摘要，而是**前瞻性结构**，指导未来行动
- **实现**：
  - **PRIME**（Tran et al., 2025）：将检索直接整合到规划循环中，确保记忆更新主动支持复杂推理步骤
  - **SayPlan**：在具身和智能体环境中，使用3D场景图作为可查询环境记忆，扩展大规模空间规划（Rana et al., 2023）
  - **Agent-S**（Agashe et al., 2025）：在GUI和家庭任务中，通过将推理锚定到层次计划来稳定长期性能
  - **KARMA**（Wang et al., 2025q）：使用记忆增强检索桥接长期知识与短期执行

**效果**：通过使计划和结构化环境表示成为工作记忆的可读和可写核心，智能体可以保持目标一致性并稳健地修订策略以应对感知失败（Song et al., 2023）

<br>

**总结**：多轮工作记忆围绕构建可操作状态载体而非保留原始历史。通过整合状态整合以压缩连续流、层次折叠以结构化子轨迹，以及认知规划以锚定未来行动，这些机制有效将推理性能与交互长度解耦。这一范式使智能体能够在无限范围内保持时间连贯性和目标对齐，同时遵守严格的计算和记忆约束。

<br>



<br>

## 5. Operations

<br>

### 核心问题

"记忆如何工作"（Operations）。

**关键转变**：从静态存储到**动态记忆管理和利用**的范式转变。智能体记忆系统可以：
- **动态构建和更新**记忆存储
- **执行定制检索**，根据不同查询条件
- **自适应能力**：自主提取精炼、可泛化的知识
- **动态融合和更新**：将新提取的知识与现有记忆库融合
- **持续适应**：适应不断变化的环境，缓解认知冲突

<br>

### 记忆生命周期

记忆系统不是静态的，而是经历完整的**生命周期**，包括三个基本过程：

#### 1. Memory Formation（记忆形成，5.1节）

**问题**："如何提取记忆？"

**功能**：将原始经验转化为信息密集的知识

**特点**：
- 不是被动记录所有交互历史
- **选择性识别**具有长期效用的信息
- 提取成功推理模式、环境约束等

#### 2. Memory Evolution（记忆演化，5.2节）

**问题**："如何精炼记忆？"

**功能**：动态演化记忆系统

**机制**：
- 整合新形成的记忆与现有记忆库
- **相关条目巩固**：合并相关记忆
- **冲突解决**：处理矛盾信息
- **自适应修剪**：删除过时或冗余信息

**目标**：确保记忆保持可泛化、连贯、高效

#### 3. Memory Retrieval（记忆检索，5.3节）

**问题**："如何利用记忆？"

**功能**：确定检索记忆的质量

**过程**：
- 根据上下文构建任务感知查询
- 使用精心设计的检索策略访问适当的记忆库
- 检索的记忆既语义相关又功能关键

<br>

### 三个过程的相互关系

这三个过程**不是独立的**，而是形成**相互连接的循环**：

1. **记忆形成**阶段提取的记忆在**记忆演化**阶段被整合和更新到现有记忆库中
2. 利用前两个阶段构建的记忆库，**记忆检索**阶段实现有针对性的访问以优化推理
3. 推理结果和环境反馈**反馈到**记忆形成以提取新见解，**反馈到**记忆演化以精炼记忆库

**整体效果**：使LLM从静态条件生成器转变为**动态系统**，能够持续学习和响应不断变化的环境

<br>

---

<br>

### 5.1 Memory Formation（记忆形成）

<br>

#### 定义与必要性

**定义**：将原始上下文（如对话或图像）编码为**紧凑知识**的过程

**必要性来源**：
- **扩展限制**：处理冗长、嘈杂、高度冗余的原始上下文存在计算开销
- **内存占用**：完整上下文提示往往遇到计算开销、禁止性内存占用
- **性能下降**：在分布外输入长度上推理性能下降

**解决方案**：将基本信息提炼为高效存储和精确检索的表示，实现更高效和有效的推理

<br>

#### 与前面章节的关系

记忆形成过程**不是独立的**，而是：
- 根据任务类型，**选择性提取**第3章描述的不同架构记忆
- 以**履行**第4章概述的相应功能

根据**信息压缩粒度**和**编码逻辑**，记忆形成过程分为五种类型。

<br>

#### 分类体系

##### 5.1.1 Semantic Summarization（语义总结）

**定义**：将冗长的原始数据转换为**紧凑、语义丰富的摘要**

**特点**：
- 捕获原始数据的**全局、高级信息**，而非特定事实或经验细节
- 过滤冗余内容，同时保留任务相关的全局语义
- 提供高级指导蓝图，不引入过多上下文开销

**典型示例**：
- 文档的总体叙述（Kim and Kim, 2025; Yu et al., 2025a）
- 任务的程序流程（Ye et al., 2025a; Zhang et al., 2025q）
- 用户的历史档案（Zhang, 2024; Westhäußer et al., 2025）

<br>

**实现方式**：

**增量语义总结（Incremental Semantic Summarization）**

- **机制**：采用时间整合机制，持续融合新观察信息与现有摘要，产生演化的全局语义表示
- **优势**：
  - 支持增量学习（McCloskey and Cohen, 1989）
  - 规避完整序列处理的O(n²)计算负担（Yu et al., 2025a）
  - 促进向全局语义的渐进收敛（Chen et al., 2024b）

- **演进过程**：
  1. **早期实现**：
     - **MemGPT**（Packer et al., 2023a）：在适当时刻直接合并新块与现有摘要
     - **Mem0**（Chhikara et al., 2025）：类似方法
     - **局限**：依赖LLM固有总结能力，受模型有限容量约束，常导致不一致或语义漂移

  2. **改进方法**：
     - **Chen et al. (2024b)**：整合外部评估器过滤冗余或不连贯内容
     - **Wu et al. (2025i)**：使用基于卷积的判别器进行一致性验证，使用DeBERTa过滤琐碎内容

  3. **学习优化**：
     - **Mem1**（Zhou et al., 2025b）：通过PPO强化学习增强LLM自身总结能力
     - **MemAgent**（Yu et al., 2025a）：使用GRPO增强总结能力
     - **效果**：总结能力逐渐内化到模型中，减少跨迭代的累积错误

- **局限**：串行更新性质仍存在计算瓶颈（Fang et al., 2025b）和潜在信息遗忘，促使分区语义总结方法发展

**分区语义总结（Partitioned Semantic Summarization）**

- **机制**：采用空间分解机制，将信息划分为不同语义分区，为每个分区生成单独摘要

- **演进过程**：
  1. **早期研究**：采用启发式分区策略处理长上下文
     - **MemoryBank**（Zhong et al., 2024）：将每天或每个会话作为基本单位总结和聚合长期对话
     - **COMEDY**（Chen et al., 2025c）：类似方法
     - **Wu et al. (2021)**：沿结构维度，将长文档分段为章节或段落，生成摘要的摘要
     - **Bailly et al. (2025)**：类似方法
     - **问题**：此类方法常遭受跨分区语义不连续性

  2. **改进方法**：
     - **ReadAgent**（Lee et al., 2024a）：在总结前引入语义或主题聚类
     - **LightMem**（Fang et al., 2025b）：增强块间连贯性

  3. **多模态扩展**：
     - **DeepSeek-OCR**（Wei et al., 2025a）：通过光学2D映射压缩长上下文，在多模态场景中实现更高压缩比
     - **视频记忆领域**：
       - **FDVS**（You et al., 2024）：将长视频分段为片段
       - **LangRepo**（Kahatapitiya et al., 2025）：整合多源信号（字幕、物体检测、场景描述）生成文本摘要，然后层次聚合为全局长视频故事

- **优势**：相比增量总结，分区方法提供更高效率并捕获更细粒度语义

- **局限**：独立处理每个子块可能导致跨分区语义依赖丢失

<br>

**总结**：语义总结作为有损压缩机制，旨在从冗长交互日志中提炼要点。与逐字存储不同，它优先考虑全局语义连贯性而非局部事实精度，将线性流转换为紧凑叙述块。主要优势是效率：大幅减少上下文长度，使其成为长期对话的理想选择。权衡是分辨率损失：特定细节或微妙线索可能被平滑掉，限制其在证据关键任务中的效用。

<br>

##### 5.1.2 Knowledge Distillation（知识蒸馏）

**定义**：以**更细粒度**从交互轨迹或文档中提取可重用知识

**与语义总结的区别**：
- **语义总结**：在宏观层面捕获原始数据的全局语义
- **知识蒸馏**：提取可重用知识

**知识形式**：取决于任务的基础功能，对应第4章描述的各种事实和经验记忆形式

<br>

**子类别**：

**提炼事实记忆（Distilling Factual Memory）**

- **目标**：将原始交互和文档转换为关于用户和环境状态的**明确、陈述性知识**

- **用户建模领域**：
  - **TiM**（Liu et al., 2023a）：采用抽象机制将对话轮次转换为高级思想或基于主题的记忆
  - **RMM**（Tan et al., 2025c）：保留长期角色连贯性

- **用户目标建模**：
  - **MemGuide**（Du et al., 2025b）：从对话中提取用户意图描述，在推理时捕获和更新目标状态，分离确认约束与未解决意图以减轻目标漂移

- **多模态环境**：
  - **ESR**（Shen et al., 2024）：将自我中心视觉观察压缩为关于物体位置和用户习惯的文本可寻址事实
  - **M3-Agent**（Long et al., 2025）：类似方法

**提炼经验记忆（Distilling Experiential Memory）**

- **目标**：从历史轨迹中提取**任务执行的底层策略**

- **机制**：通过从成功推演中推导规划原则，从失败中提取纠正信号，增强智能体在特定任务上的问题解决能力

- **抽象和泛化**：进一步支持跨任务知识转移

- **结果**：经验泛化使智能体能够持续精炼其能力，走向终身学习

<br>

**实现方法**：

**成功驱动蒸馏**：
- **AgentRR**（Feng et al., 2025）：从成功案例中总结整体任务计划
- **AWM**（Wang et al., 2024l）：类似方法
- **Memp**（Fang et al., 2025d）：分析和总结训练集中的黄金轨迹，将其提炼为抽象程序知识

**失败驱动反思**：
- **Matrix**（Liu et al., 2024）：比较推理痕迹与真实答案以识别错误源并提取反思见解
- **SAGE**（Liang et al., 2025）：类似方法
- **R2D2**（Huang et al., 2025c）：类似方法

**对比方法**：
- **ExpeL**（Zhao et al., 2024）：对比成功和失败经验以揭示整体规划见解
- **From Experience to Strategy**（Xia et al., 2025）：类似方法

**细粒度改进**：
- **H2R**（Ye et al., 2025b）：引入两级反思机制
  - 遵循ExpeL构建高级规划见解池
  - 进一步按子目标序列分割轨迹以推导逐步执行见解

<br>

**方法演进**：

**早期方法**：
- 依赖固定提示进行见解提取
- 性能对提示设计和底层LLM容量敏感

**可训练蒸馏方法**：
- **Learn-to-Memorize**（Zhang et al., 2025t）：优化不同智能体的任务特定提示
- **Memory-R1**（Yan et al., 2025b）：使用LLMExtract模块获取经验和事实知识，仅后续融合组件被训练以将这些输出整合到记忆库中
- **局限**：仍不足以增强LLM提炼见解的内在能力

**最新进展**：
- **Mem-α**（Wang et al., 2025o）：明确训练LLM提取哪些见解以及如何保留它们

<br>

**总结**：知识蒸馏专注于从原始上下文中提取功能特定知识，不涉及记忆存储结构。每个知识片段可视为扁平记忆单元。简单地将多个单元存储在非结构化表中忽略了它们之间的语义和层次关系。为解决此问题，记忆形成过程可以应用结构化规则推导见解并将其存储在层次架构中。这里介绍的单知识蒸馏方法作为更复杂和结构化记忆形成机制的基础组件。

<br>

##### 5.1.3 Structured Construction（结构化构建）

**定义**：将非结构化数据转换为**有组织的拓扑表示**

**特点**：
- 不仅仅是存储格式的变化
- 是**主动结构操作**，决定信息如何链接和分层
- 与无结构纯文本总结不同，结构化提取显著增强可解释性和检索效率

**关键优势**：在捕获多跳推理任务中的复杂逻辑和依赖方面，此类结构化先验提供优于传统检索增强方法的显著优势

<br>

**分类体系**（基于底层结构推导的操作粒度）：

**实体级构建（Entity-Level Construction）**

- **基础结构**：从关系三元组提取推导，将原始上下文分解为最细粒度语义原子实体和关系

- **平面知识图谱**：
  - **KGT**（Sun et al., 2024）：实时个性化机制，用户偏好和反馈直接编码为用户特定知识图谱中的节点和边
  - **Mem0g**（Chhikara et al., 2025）：在提取阶段使用LLM将对话消息直接转换为实体和关系三元组
  - **局限**：直接提取方法常受LLM固有能力限制，导致潜在噪声或结构错误

- **改进方法**：
  - **D-SMART**（Lei et al., 2025）：采用精炼方法
    1. 首先使用LLM将核心语义内容提炼为简洁、断言式自然语言语句
    2. 随后通过神经符号管道提取OWL兼容知识图谱片段
  - **Ret-LLM**（Modarressi et al., 2023）：对LLM应用监督微调，实现与关系图的更稳健读写交互

- **层次记忆**：
  - **GraphRAG**（Edge et al., 2025）：从源文档推导实体知识图谱，应用社区检测算法提取图谱社区并迭代生成社区摘要
  - **优势**：识别实体间更高级别集群关联，支持提取泛化见解并在不同粒度实现灵活检索

- **双图层结构**：
  - **AriGraph**（Anokhin et al., 2024）：建立包含语义和情节图谱的双层结构
  - **HippoRAG**（Gutierrez et al., 2024）：从对话中提取语义三元组，同时连接同时出现的节点或建立节点-段落索引

- **三层时间图谱架构**：
  - **Zep**（Rasmussen et al., 2025）：形式化为三层架构
    1. **情节子图（Ge）**：通过双时间模型记录原始消息的出现和处理时间
    2. **语义子图（Gs）**：实体和时间有界事实
    3. **社区子图（Gc）**：实体的高级聚类和摘要

**块级构建（Chunk-Level Construction）**

- **定义**：将连续文本跨度或离散记忆项视为节点，保留局部语义完整性同时将其组织为拓扑结构

- **演进过程**：

  1. **静态平面（2D）提取**（从固定语料库）：
     - **HAT**（A et al., 2024）：通过分段处理长文本并逐步聚合摘要构建层次树
     - **RAPTOR**（Sarthi et al., 2024）：使用UMAP进行降维和高斯混合模型进行软聚类递归聚类文本块，迭代总结这些聚类形成树
     - **局限**：静态方法缺乏灵活性，无法处理流数据而不进行昂贵重建

  2. **动态平面方法**（随着新轨迹到达增量构建记忆结构）：
     - **基于原始文本**：
       - **MemTree**（Rezazadeh et al., 2025c）：自底向上方法，新文本片段检索最相似节点并作为子节点插入或迭代插入子树，触发所有父节点的自底向上摘要更新
       - **H-MEM**（Sun and Zeng, 2025）：自顶向下策略，提示LLM将数据组织为包含域、类别、记忆痕迹和情节层的四级JSON层次结构
     - **基于提取记忆项**：
       - **A-MEM**（Xu et al., 2025c）：将知识总结为离散笔记并链接相关笔记构建网络记忆
       - **PREMem**（Kim et al., 2025b）：聚类提取的事实、经验和主观记忆以识别和存储更高维跨会话推理模式

  3. **层次（3D）架构**（超越平面布局构建层次结构，提供更丰富语义深度）：
     - **SGMem**（Wu et al., 2025h）：使用NLTK将文本分割为句子，在所有句子节点间形成KNN图，随后调用LLM提取每个对话对应的摘要、事实和见解
     - **CAM**（Li et al., 2025f）：基于语义相关性和叙述连贯性在文本块间建立边，迭代总结自我图并处理新记忆插入，通过节点复制明确解耦重叠聚类
     - **多智能体场景**：
       - **G-memory**（Zhang et al., 2025c）：扩展动态3D方法，维护三个不同图谱
         1. 原始聊天历史的交互图
         2. 特定任务的查询图
         3. 见解图
       - **效果**：使每个智能体能够在不同粒度接收定制记忆

<br>

**总结**：结构化构建的主要优势是可解释性和处理复杂关系查询的能力。此类方法捕获记忆元素间复杂语义和层次关系，支持多步依赖推理，促进与符号或基于图的推理框架集成。缺点是模式刚性：预定义结构可能无法表示细微或模糊信息，提取和维护成本通常较高。

<br>

##### 5.1.4 Latent Representation（潜在表示）

**定义**：将原始经验编码为**机器原生格式**（如向量嵌入或KV状态）的连续潜在空间

**与前两种方法的区别**：
- **语义压缩和结构化提取**：在嵌入为向量之前总结经验
- **潜在编码**：在潜在空间中固有存储经验，减少总结和文本嵌入期间的信息损失

**优势**：
- 更有利于**机器认知**
- 实现跨不同模态的**统一表示**
- 确保记忆表示的**密度和语义丰富性**

<br>

**子类别**：

**文本潜在表示**

- **KV缓存视角**：
  - 虽然最初设计用于加速推理，但在记忆上下文中可视为潜在表示形式（Li et al., 2025c; Jiang et al., 2025b）
  - 利用额外内存存储过去信息，避免冗余计算

- **可更新潜在嵌入**：
  - **MEMORYLLM**（Wang et al., 2024j）：将记忆表示为自可更新潜在嵌入，在推理期间注入Transformer层
  - **M+**（Wang et al., 2025m）：类似方法

- **记忆触发和放弃机制**：
  - **MemGen**（Zhang et al., 2025d）：引入记忆触发器监控智能体推理状态并确定何时显式调用记忆，以及记忆放弃利用智能体当前状态构建潜在令牌序列，作为机器原生记忆丰富智能体推理能力

**多模态潜在表示**

- **视觉-语言压缩**：
  - **CoMEM**（Wu et al., 2025d）：通过Q-Former将视觉-语言输入压缩为固定长度令牌，实现密集、连续记忆并支持即插即用使用以实现无限上下文长度
  - **Encode-Store-Retrieve**（Shen et al., 2024）：使用Ego-LLaVA将自我中心视频帧转换为语言编码，随后通过嵌入模型转换为向量表示
  - **权衡**：虽然使用嵌入模型确保语义对齐，但这些方法常面临压缩损失与计算开销之间的权衡，特别是在处理长上下文序列中的梯度流方面

- **具身AI集成**：
  - **Mem2Ego**（Zhang et al., 2025l）：动态对齐全局上下文信息与局部感知，将地标语义嵌入为潜在记忆以增强长期任务中的空间推理和决策
  - **KARMA**（Wang et al., 2025q）：采用混合长期和短期记忆形式，将物体信息编码为多模态嵌入，实现即时响应性和一致表示之间的平衡

<br>

**总结**：潜在表示绕过人类可读格式，将经验直接编码为机器原生向量或KV缓存。这种高密度格式保留可能在文本解码中丢失的丰富语义信号，实现与模型内部计算的更平滑集成，并支持多模态对齐。然而，它遭受不透明性：潜在记忆是黑盒，使人类难以调试、编辑或验证其存储的知识。

<br>

##### 5.1.5 Parametric Internalization（参数内化）

**定义**：将外部记忆**直接整合到模型参数空间**，通过参数更新

**特点**：
- 利用模型通过其学习参数空间编码和泛化信息的能力
- 从根本上增强模型的**内在能力**
- 消除外部存储和检索的开销
- 无缝支持持续更新

<br>

**分类体系**（基于记忆内容功能）：

**知识内化（Knowledge Internalization）**

- **定义**：将外部存储的事实记忆（如概念定义或领域知识）转换为模型参数空间

- **效果**：模型可以直接回忆和利用这些事实，无需依赖显式检索或外部记忆模块

- **实现方法**：通常通过**模型编辑**实现（Sinitsin et al., 2020; De Cao et al., 2021）

- **演进过程**：
  1. **早期工作**：
     - **MEND**（Mitchell et al., 2022）：引入辅助网络，通过分解微调梯度实现快速、单步编辑，最小化与无关知识的干扰

  2. **精炼方法**：
     - **ROME**（Meng et al., 2022）：使用因果追踪精确定位存储特定事实的MLP层，应用秩一更新注入新信息，具有更高精度和更好泛化

  3. **批量编辑**：
     - **MEMIT**（Meng et al., 2023）：通过多层残差分布和批量公式支持批量编辑，使数千个事实能够同时更新，大幅提高可扩展性

  4. **参数高效范式**：
     - **CoLoR**（Wistuba et al., 2023）：冻结预训练Transformer参数，仅训练小LoRA适配器内化新知识，避免全参数微调的高成本

- **局限**：仍可能产生脱靶效应（De Cao et al., 2021），在持续学习场景中仍易受灾难性遗忘影响

**能力内化（Capability Internalization）**

- **定义**：将经验知识（如程序专业知识或策略启发式）嵌入模型参数空间

- **特点**：代表广义记忆形成操作，从获取事实知识转向内化经验能力

- **包含能力**：
  - 领域特定解决方案模式
  - 策略规划
  - 智能体技能的有效部署
  - 其他程序能力

- **实现方法**：
  - **监督微调**（Wei et al., 2022; Zelikman et al., 2022; Schick et al., 2023; Mukherjee et al., 2023）
  - **偏好引导优化方法**：
    - **DPO**（Rafailov et al., 2023; Tunstall et al., 2023; Yuan et al., 2024c; Grattafiori et al., 2024）
    - **GRPO**（Shao et al., 2024; DeepSeek-AI et al., 2025）

- **注意**：此方面不在典型智能体记忆研究范围内，本节不详细讨论

<br>

**总结**：参数内化代表记忆的最终巩固，外部知识通过梯度融合到模型权重中。这从检索信息范式转变为拥有能力，模仿生物长期增强。随着知识变得有效本能，访问是零延迟，使模型能够立即响应而无需查询外部记忆。然而，此方法面临若干挑战，包括灾难性遗忘和高更新成本。与外部记忆不同，参数化内化难以精确修改或移除而不产生意外副作用，限制灵活性和适应性。

<br>

**记忆形成策略的整合**：虽然我们将这些方法分为五种类型，但我们认为这些记忆形成策略**不是互斥的**。单个算法可以整合多种记忆形成策略并在不同表示之间转换知识（Li et al., 2025k）。

<br>

---

<br>

### 5.2 Memory Evolution（记忆演化）

<br>

#### 定义与必要性

**定义**：整合新提取的记忆与现有记忆库，实现记忆系统的**动态演化**

**必要性**：
- **简单追加策略的局限**：
  - 忽略记忆条目间的语义依赖
  - 忽视潜在矛盾
  - 忽略信息的时间有效性

**解决方案**：引入记忆演化机制，巩固新记忆和现有记忆以合成高级见解，解决逻辑冲突，并修剪过时数据

**目标**：通过确保长期知识的紧凑性、一致性和相关性，使记忆系统能够适应其认知过程和上下文理解，随着环境和任务演化

<br>

#### 分类体系（基于记忆演化目标）

##### 5.2.1 Memory Consolidation（记忆巩固）

**定义**：将新获得的短期痕迹转化为**结构化、可泛化的长期知识**

**核心机制**：识别新记忆与现有记忆间的语义关系，并将它们整合为更高级别抽象或见解

**两个主要目的**：
1. **重组碎片信息**：将碎片信息重组为连贯结构，防止短期保留期间关键细节丢失，并支持稳定知识模式的形成
2. **抽象和泛化**：通过抽象、压缩和泛化经验数据，从特定事件中提取可重用模式，产生支持跨任务泛化的见解

<br>

**关键挑战**：确定新记忆应与现有记忆匹配和合并的粒度

**实现策略**（从局部内容合并到集群级融合再到全局整合）：

**局部巩固（Local Consolidation）**

- **操作焦点**：涉及高度相似记忆片段的细粒度更新

- **实现方法**：
  - **RMM**（Tan et al., 2025c）：每个新主题记忆检索其top-K最相似候选，LLM决定是否适合合并，从而降低错误泛化风险
  - **VLN**（Song et al., 2025b）：在多模态设置中，当容量饱和时触发池化机制，识别最相似或冗余记忆对并将它们压缩为更高级别抽象

- **优势**：在保留记忆存储全局结构的同时精炼详细知识，提高精度和存储效率

- **局限**：无法完全捕获集群级关系或跨语义相关记忆出现的高阶依赖

**集群级融合（Cluster-level Fusion）**

- **必要性**：随着记忆增长，采用集群级融合对于捕获跨实例规律性至关重要

- **跨集群方法**：
  - **PREMem**（Kim et al., 2025b）：将新记忆集群与相似现有集群对齐，应用泛化和精炼等融合模式形成更高级别推理单元，大幅提高可解释性和推理深度

- **集群内方法**：
  - **TiM**（Liu et al., 2023a）：定期调用LLM检查共享相同哈希桶的记忆，合并语义冗余条目
  - **CAM**（Li et al., 2025f）：将目标集群内所有节点合并为代表摘要，产生更高级别和一致的跨样本表示

- **效果**：在更广泛规模上重组记忆结构，标志着向结构化知识的重要步骤

**全局整合（Global Integration）**

- **操作**：执行整体巩固以维护全局连贯性并从累积经验中提炼系统级见解

- **与语义总结的区别**：
  - **语义总结**（5.1.1节）：专注于从现有上下文推导全局摘要，可视为摘要的初始构建
  - **全局整合**：强调新信息如何作为额外数据到达时整合到现有摘要中

- **实现方法**：
  - **用户事实记忆**：
    - **MOOM**（Chen et al., 2025d）：通过基于规则的处理、嵌入方法和LLM驱动抽象，整合临时角色快照与历史痕迹构建稳定角色档案
  - **经验记忆**：
    - **Matrix**（Liu et al., 2024）：执行迭代优化以结合执行轨迹和反思见解与全局记忆，提炼支持跨场景重用的任务无关原则
  - **工作记忆压缩**：
    - **AgentFold**（Ye et al., 2025a）：随着单步推理上下文和环境反馈延长，内化压缩工作记忆的能力
    - **Context Folding**（Zhang et al., 2025q）：在包括网络导航的多步交互中，这些方法在每步后自动总结和压缩全局上下文，支持高效和有效推理

- **效果**：从完整经验历史中巩固高级、结构化知识，提供可靠上下文基础，同时提高泛化、推理准确性和个性化决策

<br>

**总结**：巩固是将碎片短期痕迹重组为连贯长期模式的认知过程。它超越简单存储，综合孤立条目间的连接，形成结构化世界观。它增强泛化并减少存储冗余。然而，它存在信息平滑风险，在抽象过程中可能丢失异常事件或独特例外，可能降低智能体对异常和特定事件的敏感性。

<br>

##### 5.2.2 Memory Updating（记忆更新）

**定义**：当出现冲突或获得新信息时，智能体修订或替换其现有记忆的过程

**目标**：在不进行完整模型重训练的情况下，维护事实一致性和持续适应

**与记忆巩固的区别**：
- **记忆巩固**（5.2.1节）：专注于抽象和泛化
- **记忆更新**：强调**局部纠正和同步**，使智能体保持与演化环境对齐

**核心价值**：通过持续更新，智能体记忆系统保持知识的准确性和及时性，防止过时信息偏向推理。因此，它是实现终身学习和自我进化的核心机制

<br>

**分类体系**（基于记忆位置）：

**外部记忆更新（External Memory Update）**

- **定义**：每当出现矛盾或新事实时，修订向量数据库或知识图谱中的条目

- **特点**：不改变模型权重，通过外部存储的动态修改维护事实对齐

- **问题**：静态记忆不可避免地积累过时或冲突条目，导致逻辑不一致和推理错误

- **演进过程**：

  1. **早期系统**（基于规则的纠正）：
     - **MemGPT**（Packer et al., 2023a）：LLM检测新信息与现有信息间的冲突，然后调用替换或删除操作更新记忆
     - **D-SMART**（Lei et al., 2025）：类似方法
     - **Mem0g**（Chhikara et al., 2025）：类似方法
     - **局限**：虽然对基本事实修复有效，但这些系统依赖破坏性替换，擦除有价值历史上下文并破坏时间连续性

  2. **时间感知软删除**：
     - **Zep**（Rasmussen et al., 2025）：引入时间注释，用无效时间戳标记冲突事实而非删除它们，从而保留语义一致性和时间完整性
     - **转变**：从硬替换到软、时间感知更新

  3. **延迟一致性策略**：
     - **问题**：实时更新在高频交互下施加显著计算和I/O负担
     - **解决方案**：
       - **MOOM**（Chen et al., 2025d）：引入双相更新
         1. 实时响应的软在线更新
         2. 离线反思巩固阶段，合并相似条目并通过LLM推理解决冲突
       - **LightMem**（Fang et al., 2025b）：类似方法
     - **效果**：最终一致性范式平衡延迟和连贯性

  4. **完全学习更新策略**：
     - **Mem-α**（Wang et al., 2025o）：将记忆更新框架为策略学习问题，使LLM能够学习何时、如何以及是否更新，从而实现稳定性和新鲜度之间的动态权衡

- **整体演进**：外部记忆更新已从手动触发纠正转变为自我调节、时间感知学习过程，通过LLM驱动检索、冲突检测和修订维护事实一致性和结构稳定性

**模型编辑（Model Editing）**

- **定义**：在模型参数空间内执行直接修改以纠正或注入知识，无需完整重训练

- **特点**：代表隐式知识更新

- **优势**：重训练成本高昂且易受灾难性遗忘影响。模型编辑实现精确、低成本纠正，增强适应性和内部知识保留

- **方法类别**：

  1. **显式定位和修改**：
     - **ROME**（Tan et al., 2025b）：通过梯度追踪识别编码特定知识的参数区域，执行目标权重更新
     - **Model Editor Networks**（Tang et al., 2025c）：训练辅助元编辑器网络预测最优参数调整

  2. **潜在空间自更新**：
     - **MEMORYLLM**（Xu et al., 2025c）：在Transformer层内嵌入记忆池，定期替换记忆令牌以整合新知识
     - **M+**（Wang et al., 2025m）：维护双层记忆，丢弃过时短期条目并将关键信息压缩为长期存储

- **混合方法**：
  - **ChemAgent**（Tang et al., 2025c）：进一步结合外部记忆更新与内部模型编辑，同步事实和表示变化以实现快速跨域适应

<br>

**总结**：从实现角度看，记忆更新专注于解决由新记忆到达触发的冲突和修订知识，而记忆巩固强调新记忆和现有知识的整合和抽象。上述两种记忆更新策略建立了涉及外部数据库中冲突解决和模型内参数编辑的双路径机制，使智能体能够执行持续自我纠正并支持长期演化。关键挑战是稳定性-可塑性困境：确定何时覆盖现有知识与何时将新信息视为噪声。不正确更新可能覆盖关键信息，导致知识退化和错误推理。

<br>

##### 5.2.3 Memory Forgetting（记忆遗忘）

**定义**：**故意移除**过时、冗余或低价值信息以释放容量并保持对突出知识的关注

**与更新机制的区别**：
- **更新机制**：解决记忆间的冲突
- **记忆遗忘**：优先消除过时信息以确保效率和相关性

**必要性**：随时间推移，无界记忆积累导致：
- 噪声增加
- 检索延迟
- 过时知识的干扰

**受控遗忘**有助于缓解过载并保持认知焦点

**权衡**：过于激进的修剪可能擦除罕见但必要的知识，在长期上下文中损害推理连续性

<br>

**分类体系**（基于遗忘标准）：

**基于时间的遗忘（Time-based Forgetting）**

- **机制**：仅考虑记忆的创建时间，随时间逐渐衰减其强度以模拟人类记忆衰退

- **实现方法**：
  - **MemGPT**（Packer et al., 2023a）：上下文溢出时驱逐最早消息
  - **Xu et al. (2025c)**：采用随机令牌替换，替换比率为K/N，模拟人类认知中的指数遗忘，一旦池超过容量就丢弃最旧条目
  - **Wang et al. (2025m)**：类似方法
  - **MAICC**（Jiang et al., 2025c）：实现软遗忘，随时间逐渐衰减记忆权重，确保持续适应而不历史过载

- **特点**：镜像自然遗忘，确保持续适应而不历史过载

**基于频率的遗忘（Frequency-based Forgetting）**

- **机制**：基于检索行为优先记忆，保留频繁访问条目同时丢弃不活跃条目

- **实现方法**：
  - **XMem**（Cheng and Schwing, 2022）：采用LFU策略移除低频率条目
  - **KARMA**（Wang et al., 2025q）：使用计数布隆过滤器跟踪访问频率
  - **MemOS**（Li et al., 2025k）：应用LRU策略，移除长期未使用项同时归档高活跃项

- **效果**：确保高效检索和存储平衡

- **与基于时间遗忘的关系**：通过区分创建时间和检索频率，这两个轴形成更正交的分类：基于时间的衰减捕获自然时间老化，而基于频率的遗忘反映使用动态，共同维护系统效率和新近性

**重要性驱动遗忘（Importance-driven Forgetting）**

- **机制**：整合时间、频率和语义信号以保留高价值知识同时修剪冗余

- **演进过程**：

  1. **早期工作**（数值评分）：
     - **Zhong et al. (2024)**：通过结合时间衰减和访问频率的复合分数量化重要性
     - **Chen et al. (2025d)**：实现基于数值的选择性遗忘

  2. **语义级评估**：
     - **VLN**（Song et al., 2025b）：通过相似性聚类池化语义冗余记忆
     - **Livia**（Xi and Wang, 2025）：整合情感显著性和上下文相关性以建模情感驱动选择性遗忘

  3. **LLM判断能力**：
     - **TiM**（Liu et al., 2023a）：利用LLM评估记忆重要性并显式修剪或遗忘不太重要的记忆
     - **MemTool**（Lumer et al., 2025）：类似方法

- **转变**：从静态数值评分到语义智能的转变。智能体现在可以执行有意识遗忘，选择性保留与任务上下文、语义和情感线索最相关的记忆

<br>

**总结**：基于时间的衰减反映记忆的自然时间衰退，基于频率的遗忘确保对频繁使用记忆的高效访问，重要性驱动遗忘引入语义辨别。这三种遗忘机制共同管理智能体记忆如何保持及时、高效可访问和语义相关。然而，启发式遗忘机制如LRU可能消除长尾知识，这些知识很少访问但对正确决策至关重要。因此，当存储成本不是关键约束时，许多记忆系统避免直接删除某些记忆。

<br>

---

<br>

### 5.3 Memory Retrieval（记忆检索）

<br>

#### 定义与挑战

**定义**：从某个记忆库中检索相关和简洁知识片段以在正确时刻支持当前推理任务的过程

**关键挑战**：在大型记忆存储中**高效且准确地定位**所需知识片段

**解决方案**：许多算法采用启发式策略或可学习模型优化检索过程的各个阶段

<br>

#### 检索流程（基于执行顺序）

记忆检索过程可分解为四个方面：

1. **Retrieval Timing and Intent（检索时机和意图，5.3.1节）**：确定记忆检索的特定时刻和目标
2. **Query Construction（查询构建，5.3.2节）**：桥接用户原始输入与存储记忆索引间的语义差距
3. **Retrieval Strategies（检索策略，5.3.3节）**：在记忆库上执行搜索
4. **Post-Retrieval Processing（检索后处理，5.3.4节）**：通过重排序、过滤和聚合精炼检索的原始片段

**整体效果**：这些机制将记忆检索从静态搜索操作转变为动态认知过程。检索时机和意图确定何时何地检索。接下来，查询构建指定检索什么，检索策略专注于如何执行检索。最后，检索后处理决定检索信息如何整合和使用。稳健的智能体系统通常在统一管道内编排这些组件，使智能体能够近似类人关联记忆激活以实现高效知识访问。

<br>

##### 5.3.1 Retrieval Timing and Intent（检索时机和意图）

**定义**：确定何时触发检索机制以及查询哪个记忆存储

**设计选择范围**：
- **始终开启检索**：每次查询从所有记忆数据库检索
- **显式指令触发**：由显式指令触发
- **内部信号触发**：由内部信号触发（Zhao et al., 2024; Wang et al., 2025o; Fang et al., 2025b）

**示例**：
- **MIRIX**（Wang and Chen, 2025）：对每个查询从所有六个记忆数据库执行检索并连接检索内容，反映优先全面记忆访问的设计

**选择性检索**：其他方法旨在更选择性地触发检索，允许模型决定记忆访问的时机和范围，可导致更有针对性和高效的记忆资源使用

<br>

**两个互补视角**：

**自动检索时机（Automated Retrieval Timing）**

- **定义**：模型在推理期间自主确定何时触发记忆检索操作的能力

- **简单策略**：
  - **MemGPT**（Packer et al., 2023a）：将决策委托给LLM或外部控制器，允许其仅从查询确定检索是否必要
  - **MemTool**（Lumer et al., 2025）：允许LLM自身调用检索函数，在类似操作系统框架内实现对外部记忆的高效访问
  - **局限**：这些方法依赖仅从查询的静态判断，忽略模型在推理期间动态演化的认知状态

- **改进方法**（快-慢思考机制）：
  - **ComoRAG**（Wang et al., 2025f）：首先产生快速响应，然后让智能体评估其充分性。如果初始推理被认为不足，系统基于失败反馈触发更深检索和推理
  - **PRIME**（Tran et al., 2025）：类似方法
  - **MemGen**（Zhang et al., 2025d）：进一步精炼触发机制，将显式智能体级决策转换为潜在、可训练过程。它引入记忆触发器，从潜在展开状态检测关键检索时刻，从而提高检索时机精度同时保持端到端可微性

**自动检索意图（Automated Retrieval Intent）**

- **定义**：模型在层次存储形式内自主决定访问哪个记忆源的能力

- **示例**：
  - **AgentRR**（Feng et al., 2025）：基于环境反馈在低级程序模板和高级经验抽象之间动态切换
  - **局限**：依赖显式反馈限制了在开放端推理设置中的适用性

- **改进方法**：
  - **MemOS**（Li et al., 2025k）：采用MemScheduler，基于用户、任务或组织级上下文在参数、激活和纯文本记忆之间动态选择
  - **局限**：此平面选择方案忽略了记忆系统的层次结构

- **层次路由**：
  - **H-MEM**（Sun and Zeng, 2025）：通过引入基于索引的路由机制解决此问题，执行从域层到情节层的粗到细检索，逐渐缩小搜索空间到最相关子记忆
  - **优势**：此层次路由不仅提高检索精度，还缓解信息过载

<br>

**总结**：自主时机和意图有助于减少计算开销并抑制不必要噪声，但它们也创造潜在漏洞。当智能体高估其内部知识并在需要时未能启动检索时，系统可能陷入静默失败模式，其中知识差距可能导致幻觉输出。因此，需要实现平衡：在正确时刻为智能体提供必要信息，同时避免引入噪声的过度检索。

<br>

##### 5.3.2 Query Construction（查询构建）

**定义**：将原始查询转换为与记忆索引对齐的有效检索信号

**作用**：作为用户表面话语与记忆潜在存储之间的翻译层

**传统方法局限**：通常直接基于用户查询执行检索，简单但无法将查询语义与记忆索引对齐

**解决方案**：智能体记忆系统主动执行查询分解或查询重写，生成与记忆潜在结构更好匹配的中间检索信号

<br>

**两种范式**：

**查询分解（Query Decomposition）**

- **定义**：将复杂查询分解为更简单子查询，使系统能够检索更细粒度和相关信息

- **优势**：通过启用模块化检索和中间结果推理，缓解一次性检索瓶颈

- **实现方法**：
  - **Visconde**（Pereira et al., 2023）：使用LLM将原始问题分解为子问题，从记忆检索每个候选结果，最后将它们聚合为连贯答案
  - **ChemAgent**（Tang et al., 2025c）：类似方法
  - **局限**：这些方法缺乏全局规划

- **改进方法**（全局规划）：
  - **PRIME**（Tran et al., 2025）：引入规划器智能体，受ReAct范式启发，首先制定全局检索计划，然后将其分解为子查询
  - **MA-RAG**（Nguyen et al., 2025）：类似方法
  - **局限**：这些方法主要依赖问题驱动分解，因此无法明确识别模型缺少的特定知识

- **针对性分解**：
  - **Agent KB**（Tang et al., 2025d）：采用两阶段检索过程，教师模型观察学生模型失败并相应生成细粒度子查询
  - **效果**：此针对性分解提高检索精度并减少不相关结果，特别是在知识密集型任务中

**查询重写（Query Rewriting）**

- **定义**：重写原始查询或生成假设文档以在检索前精炼其语义

- **目标**：缓解用户意图与记忆索引之间的不匹配

- **实现方法**：
  - **HyDE**（Gao et al., 2023b）：以零样本方式指示LLM生成假设文档，并使用其语义嵌入执行检索。生成的文档封装所需语义，有效桥接用户查询与目标记忆之间的差距
  - **MemoRAG**（Qian et al., 2025）：扩展此想法，将全局记忆整合到假设文档生成中。它首先压缩全局记忆，然后基于查询和压缩记忆生成草稿答案；此草稿随后用作重写查询。由于草稿可以访问全局记忆上下文，它更忠实地捕获用户意图并揭示隐式信息需求
  - **MemGuide**（Du et al., 2025b）：利用对话上下文提示LLM产生简洁、命令式短语，作为检索的高级意图描述
  - **Rewrite-Retrieve-Read**（Ma et al., 2023b）：通过强化学习训练小型语言模型作为专用重写器
  - **ToC**（Kim et al., 2023a）：采用澄清树逐步精炼和指定用户的检索目标

<br>

**总结**：这两种范式（分解和重写）不是互斥的。**Auto-RAG**（Kim et al., 2024a）通过评估HyDE和Visconde在相同检索条件下并选择给定任务表现最佳的策略来整合两者。这项工作的发现表明，记忆检索查询的质量对推理性能有重大影响。与主要关注设计复杂记忆架构的早期研究相比，最近的研究（Yan et al., 2025a）越来越强调检索构建过程，将记忆的角色转向服务检索。毫不奇怪，选择检索什么的过程是这一过程的关键组成部分。

<br>

##### 5.3.3 Retrieval Strategies（检索策略）

**定义**：在明确检索目标后，利用查询在大型复杂记忆库中高效且准确地检索真正相关知识的方法

**作用**：作为查询与记忆库之间的桥梁，其设计直接决定检索效率和结果质量

**本节内容**：系统回顾各种检索范式，分析其优势、局限和应用场景

<br>

**检索范式分类**：

**词汇检索（Lexical Retrieval）**

- **机制**：依赖关键词匹配定位相关文档
- **代表方法**：
  - **TF-IDF**（SPARCK JONES, 1972）：基于词频和逆文档频率测量关键词重要性，实现快速和可解释检索
  - **BM25**（Robertson and Zaragoza, 2009）：通过纳入词频饱和和文档长度归一化进一步精炼此方法
- **应用场景**：通常用于精度导向检索场景，其中结果准确性和相关性优先于召回（Tang et al., 2025d; Wang et al., 2025o; Pan et al., 2025）
- **局限**：纯词汇匹配难以捕获语义变化和上下文关系，使其对语言表达差异高度敏感，因此在开放域知识或多模态记忆设置中效果较差

<br>

**语义检索（Semantic Retrieval）**

- **机制**：将查询和记忆条目编码到共享嵌入空间，基于语义相似性而非词汇重叠匹配它们
- **代表方法**：
  - **Sentence-BERT**（Reimers and Gurevych, 2019）：语义编码器
  - **CLIP**（Radford et al., 2021）：多模态语义编码器
- **优势**：
  - 更好捕获任务上下文
  - 支持语义泛化和模糊匹配
  - 成为大多数智能体记忆框架的默认选择（Lewis et al., 2020; Wang et al., 2024b; Yang et al., 2024a; Xu et al., 2025c; Tan et al., 2025c; Nguyen et al., 2025; Qian et al., 2025; Hassell et al., 2025; Huang et al., 2025c）
- **挑战**：
  - 语义漂移和强制top-K检索常引入检索噪声和虚假召回
- **解决方案**：最近系统整合动态检索策略、重排序模块和混合检索方案

<br>

**图检索（Graph Retrieval）**

- **机制**：不仅利用语义信号，还利用图的显式拓扑结构，实现本质上更精确和结构感知的检索
- **优势**：
  - 通过直接访问结构路径，这些方法表现出更强的多跳推理能力
  - 可以更有效地探索长程依赖
  - 将关系结构视为推理路径的约束，自然支持由精确规则和符号约束管理的检索
- **实现方法**：
  - **基础方法**（节点扩展）：
    - **AriGraph**（Anokhin et al., 2024）
    - **EMG-RAG**（Wang et al., 2024k）
    - **Mem0g**（Chhikara et al., 2025）
    - **SGMem**（Wu et al., 2025h）
    - **方法**：首先识别最相关节点或三元组，然后扩展到其语义相关的K跳邻居以构建自我图
  - **个性化PageRank**：
    - **HippoRAG**（Gutierrez et al., 2024）：在检索节点上执行个性化PageRank（Page et al., 1999），根据它们与这些种子的接近度对图的其余部分进行排序，实现有效的多跳检索
  - **LLM引导探索**：
    - **CAM**（Li et al., 2025f）：使用LLM选择中心节点的信息邻居和子节点进行关联探索
    - **D-SMART**（Lei et al., 2025）：将LLM视为规划器，在KG记忆上执行波束搜索，检索目标实体的一跳邻居和连接给定实体对的关系
  - **时间图**：
    - **Zep**（Rasmussen et al., 2025）：在时间图中，进一步支持实体子图构建和显式时间约束下的关系检索
    - **MemoTime**（Tan et al., 2025b）：确保返回结果满足所需时间规则

<br>

**生成式检索（Generative Retrieval）**

- **机制**：用直接生成相关文档标识符的模型替换词汇或语义检索（Tay et al., 2022; Wang et al., 2022b）
- **特点**：
  - 通过将检索框架为条件生成任务，模型隐式在其参数中存储候选文档
  - 在解码期间执行深度查询-文档交互（Li et al., 2025j）
- **优势**：
  - 利用预训练语言模型的语义能力，此范式通常优于传统检索方法
  - 特别是在小规模设置中表现突出（Zeng et al., 2024）
- **局限**：
  - 需要额外训练以内化所有候选文档的语义
  - 当语料库演化时导致有限可扩展性（Yuan et al., 2024b）
- **现状**：智能体记忆系统对此范式关注相对较少，尽管生成和检索的紧密集成表明未开发的潜力

<br>

**混合检索（Hybrid Retrieval）**

- **机制**：整合多种检索范式的优势
- **实现方法**：
  - **词汇+语义**：
    - **Agent KB**（Tang et al., 2025d）：结合词汇和语义检索，平衡精确术语或工具匹配与更广泛的语义对齐
    - **MIRIX**（Wang and Chen, 2025）：类似方法
    - **Semantic Anchoring**（Chatterjee and Agarwal, 2025）：在语义嵌入和符号倒排索引上执行并行搜索以实现互补覆盖
  - **多因子评分**：
    - **Generative Agents**（Kaiya et al., 2023）：通过累积新近性、重要性和相关性的评分方案说明此多因子方法
    - **MAICC**（Jiang et al., 2025c）：采用混合效用评分函数，整合相似性与全局和预测个体回报
  - **图设置中的两阶段检索**：
    - 通常分两阶段进行：语义检索首先识别相关节点或三元组，随后利用图拓扑扩展搜索空间（Anokhin et al., 2024; Wang et al., 2024k; Gutierrez et al., 2024; Li et al., 2025f）
  - **数据库基础设施级别**：
    - **MemoriesDB**（Ward, 2025）：引入为长期智能体记忆设计的时间-语义-关系数据库，提供整合这些维度到统一存储和访问框架的混合检索架构
- **优势**：通过融合异构检索信号，混合方法保留关键词匹配的精度，同时纳入语义方法的上下文理解，最终产生更全面和相关的结果

<br>

##### 5.3.4 Post-Retrieval Processing（检索后处理）

**定义**：精炼检索的原始片段，确保注入提示的记忆简洁、准确且语义连贯

**必要性**：初始检索常返回冗余、嘈杂或语义不一致的片段。直接将这些结果注入提示可能导致：
- 过长上下文
- 冲突信息
- 推理被无关内容分散注意力

**目标**：将检索结果提炼为简洁、准确、语义连贯的上下文

<br>

**两个核心组件**：

**重排序和过滤（Re-ranking and Filtering）**

- **目标**：通过执行细粒度相关性估计移除不相关或过时记忆并重新排序剩余片段，从而减少噪声和冗余
- **实现方法**：
  - **早期方法**（启发式标准）：
    - **Semantic Anchoring**（Chatterjee and Agarwal, 2025）：整合向量相似性与实体和话语级对齐
    - **RCR-Router**（Liu et al., 2025c）：结合多个手工信号，包括角色相关性、任务阶段优先级和新近性
    - **局限**：这些方法通常需要大量超参数调整以平衡异构重要性分数
  - **学习优化**：
    - **Learn-to-Memorize**（Zhang et al., 2025t）：将分数聚合框架为强化学习问题，使模型能够学习检索信号的最优权重
  - **时间约束**：
    - **Rasmussen et al. (2025)**：基于时间戳和有效性窗口过滤记忆以满足复杂时间依赖
    - **Tan et al. (2025b)**：类似方法
  - **LLM评估**：
    - **Memory-R1**（Yan et al., 2025b）：引入基于LLM的评估器（答案智能体或自我验证智能体），在产生最终响应前过滤检索内容
    - **Westhäußer et al. (2025)**：类似方法
    - **局限**：基于提示的过滤仍受LLM固有容量和提示语义与下游使用不匹配的限制
  - **辅助模型训练**：
    - **Tan et al. (2025c)**：许多系统训练辅助模型以更稳健地估计记忆重要性
    - **Memento**（Zhou et al., 2025a）：使用Q学习（Watkins and Dayan, 1992）预测检索项对正确答案贡献的概率
    - **MemGuide**（Du et al., 2025b）：微调LLaMA-8B（Grattafiori et al., 2024）使用边际槽完成增益重新排序候选
- **优势**：这些重排序和过滤策略在不修改底层检索器的情况下精炼检索结果，使它们与任何预训练检索模型兼容，同时支持任务特定优化

<br>

**聚合和压缩（Aggregation and Compression）**

- **目标**：通过检索后处理提高下游推理的质量和效率
- **与过滤和重排序的区别**：
  - **过滤和重排序**：主要解决噪声和优先级
  - **聚合和压缩**：专注于将多个碎片记忆项合并为更高级别和提炼的知识表示，并在需要任务特定适应时精炼这些表示
- **实现方法**：
  - **全局摘要**：
    - **ComoRAG**（Wang et al., 2025f）：通过其集成智能体说明此想法，识别与查询语义对齐的历史信号并将它们组合为抽象全局摘要，提供广泛上下文基础
  - **细粒度内容选择**：
    - **MA-RAG**（Nguyen et al., 2025）：提取器智能体对检索文档执行细粒度内容选择，仅保留与当前子查询强烈相关的关键信息，产生针对本地推理需求定制的简洁片段
  - **多智能体个性化**：
    - **G-Memory**（Zhang et al., 2025c）：将聚合和压缩扩展到多智能体系统的个性化。它巩固检索的高级见解和稀疏轨迹，然后使用LLM根据智能体角色定制这些压缩经验。此过程将一般知识精炼为填充智能体个性化记忆的角色特定提示

<br>

**总结**：检索后处理作为关键中间步骤，将嘈杂、碎片检索结果转换为精确、连贯的推理上下文。通过上述机制，检索后处理不仅增强提供给模型的记忆的密度和保真度，还将信息与任务要求和智能体特征对齐。



<br>

## 6. 资源与框架

### Benchmark

#### 专为记忆设计的基准

##### AgentBoard（Zhou et al., 2024）

**特点**：
- **多任务场景**：涵盖对话、任务规划、工具使用等多种任务类型
- **长期交互**：模拟长期用户-Agent 交互（数周至数月）
- **用户模拟**：使用模拟用户生成多样化的交互模式
- **记忆显式评估**：直接测试记忆的保留、检索、更新能力

**评估指标**：
- **记忆保留率（Memory Retention Rate）** ：长期记忆的保留比例
- **个性化准确率（Personalization Accuracy）** ：Agent 行为与用户偏好的匹配度
- **检索精度（Retrieval Precision）** ：检索到的记忆与查询的相关性
- **一致性（Consistency）** ：Agent 在不同时间对同一用户的行为一致性

**任务示例**：
```
Task: Personal Assistant
- Day 1: User says "I prefer morning meetings"
- Day 10: User asks "Schedule a meeting"
- Expected: Agent should schedule in the morning
- Evaluation: Does agent remember the preference?
```

<br>

##### MemBench（Memory Benchmark）

**特点**：
- **显式测试记忆 CRUD 操作**：Create、Read、Update、Delete
- **覆盖记忆全生命周期**：从存储到检索到更新到遗忘
- **多记忆形式支持**：Episodic、Semantic、Procedural

**评估指标**：
- **检索精度（Retrieval Precision）** ：Recall@K、Precision@K、MRR
- **更新一致性（Update Consistency）** ：更新后记忆的一致性
- **遗忘合规性（Forgetting Compliance）** ：遗忘策略的正确性
- **冲突解决（Conflict Resolution）** ：新旧记忆冲突的处理能力

**测试场景**：
```
Scenario 1: Memory Creation
  - Store: "User prefers coffee"
  - Test: Can retrieve this memory?

Scenario 2: Memory Update
  - Old: "User prefers coffee"
  - New: "User now prefers tea"
  - Test: Is memory updated correctly?

Scenario 3: Memory Deletion
  - Store then delete: "Temporary note"
  - Test: Is memory deleted? Can it be retrieved?
```

<br>


##### LifelongQA（持续问答基准）

**特点**：
- **持续学习**：Agent 需要从持续到来的问题中学习
- **知识累积**：测试知识随时间累积的效果
- **遗忘测试**：测试长期记忆的保留能力

**评估指标**：
- **回答正确率随时间变化曲线**：学习曲线
- **知识保留率**：旧知识的记忆保留情况
- **新知识整合能力**：新知识的快速学习能力

**数据集**：
- 时间跨度：数月至数年
- 问题类型：事实性、推理性、多跳推理
- 知识领域：通用知识、领域特定知识

<br>

#### 通用 Agent 基准（隐含记忆需求）

这些基准虽未显式标注"memory"，但其特性天然要求强大的记忆系统：

##### WebArena（Zhou et al., 2023）

**特点**：
- **长周期网页操作**：需要执行多步骤、长时间的任务
- **状态管理**：需要记住之前的操作和状态
- **上下文依赖**：后续操作依赖前面的操作结果

**记忆需求**：
- **工作记忆压缩**：长序列任务需要压缩中间步骤
- **状态记忆**：记住当前任务的状态和进度
- **操作历史**：记录操作序列，支持错误回溯

**示例任务**：
```
Task: Book a flight
Steps:
  1. Search flights (NYC → LAX)
  2. Filter by preferences (direct, morning)
  3. Select flight
  4. Enter passenger info
  5. Confirm booking

Memory needed: Remember preferences, selected flight, 
               passenger info across steps
```

<br>


##### AgentBench（Liu et al., 2024）

**特点**：
- **工具使用**：测试 Agent 调用外部工具的能力
- **多步推理**：需要多步骤的推理和规划
- **任务多样性**：涵盖代码生成、数据分析、网页操作等

**记忆需求**：
- **程序记忆复用**：复用成功的工具调用模式
- **案例检索**：检索相似的历史任务案例
- **错误记忆**：记住失败的操作，避免重复错误


<br>

##### GAIA（Mialon et al., 2024）

**特点**：
- **真实世界问题**：需要整合来自多个来源的信息
- **多文档推理**：需要跨文档的记忆整合
- **长期依赖**：问题可能依赖之前的知识

**记忆需求**：
- **跨文档记忆整合**：整合来自多个文档的信息
- **知识图谱构建**：构建跨文档的知识图谱
- **长期知识保留**：保留之前学到的知识

<br>

#### 基准对比总结

| 基准 | 记忆显式性 | 时间跨度 | 主要评估维度 | 适用场景 |
|------|-----------|---------|------------|---------|
| **AgentBoard** | 显式 | 长期（周-月） | 保留、个性化、一致性 | 长期交互 Agent |
| **MemBench** | 显式 | 短期 | CRUD 操作、更新、遗忘 | 记忆系统开发 |
| **LifelongQA** | 显式 | 长期（月-年） | 知识累积、保留 | 持续学习系统 |
| **WebArena** | 隐含 | 短期（单任务） | 工作记忆、状态管理 | 网页操作 Agent |
| **AgentBench** | 隐含 | 短期（单任务） | 程序记忆、案例检索 | 通用 Agent |
| **GAIA** | 隐含 | 短期（单任务） | 跨文档整合 | 知识问答 |



<br>

### 开源框架与工具

#### 框架概览

##### G-Memory（Zhang et al., 2025c）

**核心创新**：
- **多 Agent 个性化记忆**：为每个 Agent 维护独立的记忆空间
- **图结构存储**：使用知识图谱组织记忆
- **角色特定提示**：将通用记忆转换为角色特定的 prompt

**技术栈**：
- **存储**：Neo4j 图数据库
- **检索**：Cypher 查询语言 + 向量相似性搜索
- **个性化**：LLM-based role prompting

**使用场景**：
- 多 Agent 协作系统
- 需要个性化记忆的场景
- 复杂关系查询需求

**示例**：
```python
# G-Memory 使用示例
memory = GMemory(user_id="U123", agent_role="medical_assistant")

# 存储记忆
memory.store(
    fact="User is a doctor",
    context="medical"
)

# 检索时，自动转换为角色特定提示
prompt = memory.retrieve_as_prompt(query="user background")
# Output: "The user is a medical professional (doctor), 
#          emphasize accuracy and evidence-based responses"
```

<br>

##### MA-RAG（Multi-Agent RAG, Nguyen et al., 2025）

**核心创新**：
- **检索后细粒度提取**：使用多个 Agent 对检索结果进行精细处理
- **查询分解**：将复杂查询分解为子查询
- **多 Agent 协作**：不同 Agent 负责不同的处理任务

**技术架构**：
```
Query → Query Decomposer Agent
      ↓
      [Sub-query 1, Sub-query 2, ...]
      ↓
      Retrieval (for each sub-query)
      ↓
      Extractor Agent (for each result)
      ↓
      Integration Agent
      ↓
      Final Context
```

**优势**：
- **精确提取**：只提取最相关的信息片段
- **减少噪声**：过滤掉不相关的检索结果
- **结构化输出**：输出结构化的上下文

<br>

##### ComoRAG（Wang et al., 2025f）

**核心创新**：
- **全局上下文整合**：Integration Agent 对多个检索文档进行语义对齐
- **Broad Contextual Grounding**：生成统一的、广泛的上下文摘要
- **避免信息碎片化**：将分散的信息整合为连贯的上下文

**技术流程**：
```
Multiple Retrieved Documents
    ↓
Integration Agent:
  - Semantic alignment
  - Cross-document reasoning
  - Unified summary generation
    ↓
Broad Contextual Grounding
    ↓
LLM with enriched context
```

**应用场景**：
- 需要整合多个来源信息的任务
- 复杂推理任务
- 知识问答系统

<br>


##### Matrix（Liu et al., 2024）

**核心创新**：
- **经验提炼为原则**：从 Agent 轨迹中提炼任务无关原则
- **迭代反思循环**：多轮迭代优化原则质量
- **原则驱动决策**：使用提炼的原则指导 Agent 行为

**技术流程**：
```
Agent Trajectories
    ↓
Reflection Loop:
  Round 1: Initial principle extraction
  Round 2: Refinement
  Round 3: Validation
  ...
    ↓
Task-agnostic Principles
    ↓
Principle-guided Agent Behavior
```

**优势**：
- **高度抽象**：原则可跨任务复用
- **持续改进**：通过迭代优化原则质量
- **可解释性**：原则提供决策的可解释性

<br>

#### 检索后处理（Post-Retrieval Processing）关键技术

**核心问题**：原始检索结果常**冗余、噪声大、缺乏结构**，需要后处理才能有效利用。
- **记忆质量 = 检索质量 × 后处理能力**。优秀的记忆系统不仅需要高效的检索，更需要智能的后处理来提取、整合、个性化记忆。

##### Query Decomposition（查询分解）

**方法**（MA-RAG）：
```
Complex Query: "What are the user's preferences for flights and hotels?"

Decomposed:
  - Sub-query 1: "User's flight preferences"
  - Sub-query 2: "User's hotel preferences"

For each sub-query:
  - Retrieve relevant memories
  - Extract most relevant snippets
  - Combine results
```

**优势**：
- **精确匹配**：每个子查询更精确，检索结果更相关
- **并行处理**：可以并行处理多个子查询
- **模块化**：便于组合和复用

<br>

##### Semantic Alignment（语义对齐）

**方法**（ComoRAG）：
```
Retrieved Documents:
  Doc 1: "User prefers direct flights"
  Doc 2: "User likes non-stop flights"
  Doc 3: "User booked direct flight NYC→LAX"

Semantic Alignment:
  - Recognize "direct" = "non-stop"
  - Align temporal information
  - Identify core concept: "prefers direct flights"

Unified Summary:
  "User consistently prefers direct/non-stop flights, 
   as evidenced by multiple bookings and stated preferences"
```

**技术实现**：
- **实体对齐**：识别不同文档中的相同实体
- **关系对齐**：识别相同的关系模式
- **时间对齐**：整合时间序列信息

<br>

##### Role-Specific Prompting（角色特定提示）

**方法**（G-Memory）：
```
Generic Memory: "User is a doctor"

For Medical Agent:
  Prompt: "The user is a medical professional (doctor). 
           Emphasize accuracy, evidence-based responses, 
           and use appropriate medical terminology."

For Customer Service Agent:
  Prompt: "The user is a doctor (medical professional). 
           They likely have limited time and value efficiency. 
           Be concise and respect their time constraints."
```

**优势**：
- **上下文适应**：同一记忆在不同上下文中发挥不同作用
- **个性化**：根据 Agent 角色定制记忆的使用方式
- **灵活性**：支持多 Agent 系统中的个性化


<br>

##### Reranking（重排序）

**方法**：
```
Initial Retrieval (Top 20):
  [Result 1, Result 2, ..., Result 20]

Cross-Encoder Reranking:
  For each (query, result) pair:
    score = cross_encoder(query, result)
  
  Sort by score
  Return Top 5
```

**优势**：
- **提高精度**：交叉编码器比双编码器更准确
- **考虑交互**：直接建模查询和结果的交互

**劣势**：
- **计算成本**：需要为每个候选结果计算，成本高
- **延迟**：增加检索延迟


<br>

##### Deduplication（去重）

**方法**：
```
Retrieved Results:
  Result 1: "User prefers direct flights"
  Result 2: "User likes non-stop flights"  # Similar
  Result 3: "User booked flight NYC→LAX"

Deduplication:
  - Calculate similarity between results
  - If similarity > threshold (e.g., 0.95):
      Keep most detailed version
      Remove duplicates
```

**实现**：
- **向量相似度**：使用嵌入计算相似度
- **文本相似度**：使用编辑距离、Jaccard 相似度
- **语义相似度**：使用 LLM 判断语义等价性
<br>

#### 其他框架

##### LangChain Memory

**特点**：
- **多种记忆后端**：支持向量数据库、SQL、内存等
- **易于集成**：与 LangChain 生态无缝集成
- **灵活配置**：支持多种记忆配置

**使用示例**：
```python
from langchain.memory import VectorStoreRetrieverMemory
from langchain.vectorstores import FAISS

vectorstore = FAISS.from_texts(["..."])
memory = VectorStoreRetrieverMemory(
    retriever=vectorstore.as_retriever()
)
```
<br>

##### LlamaIndex

**特点**：
- **高级检索策略**：子查询分解、时间加权检索等
- **多模态支持**：支持文本、图像等多模态记忆
- **可扩展性**：支持大规模记忆库

<br>

##### Mem0

**特点**：
- **自动记忆提取**：从对话中自动提取记忆
- **向量检索**：使用向量数据库进行高效检索
- **用户友好**：提供简单的 API
<br>



<br>

## 7. 未来展望

<br>

### 记忆检索到记忆生成

**范式转变**：传统方法以记忆检索为中心，通过索引策略、相似度度量、重排序模型或知识图谱提高检索准确性。技术包括密集嵌入向量搜索、混合检索（词汇+语义）、分层过滤、图遍历。这些方法强调精确率和召回率，隐含假设记忆库已形成良好。

**生成式记忆**：不是将记忆视为静态仓库，而是 Agent 主动按需合成新记忆表示。目标不仅是检索拼接，而是整合、压缩、重组信息以适应上下文和未来效用。有效记忆使用需要抽象和重组，特别是当原始信息存在噪声、冗余或与任务不对齐时。

**两类方法**：
- **检索后生成**：ComoRAG、G-Memory、CoMEM 先检索相关记忆子集，再生成简洁、连贯、上下文特定的精炼表示，保持历史信息基础的同时支持自适应摘要和重组。
- **直接记忆生成**：MemGen、VisMem 直接从当前上下文、交互历史或潜在内部状态生成记忆表示，构建任务定制的潜在记忆 token，完全绕过显式记忆查找。

**未来方向**：
- **上下文自适应**：生成针对 Agent 预期未来需求优化的表示，使记忆粒度、抽象级别、语义焦点适应不同任务、问题解决阶段或交互机制。
- **跨异构信号整合**：将文本、代码、工具输出、环境反馈等碎片化信号融合为统一表示，潜在记忆可能是实现路径。
- **学习且自优化**：通过强化学习或长期任务性能学习何时及如何生成记忆，使记忆生成成为 Agent 策略组成部分，与推理和决策共同演化。

<br>

### 自动化记忆管理

**现状问题**：现有系统（MemOS、Mem0、MemoBase）依赖手动设计策略确定存储内容、使用时机、更新检索方式。通过详细指令、预定义阈值、人工规则指导固定 LLM，虽能快速原型部署且提供可解释性，但本质上不灵活，难以在多样化动态环境中泛化，长期或开放式交互表现不佳。

**初步进展**：CAM 使 LLM Agent 自动将细粒度记忆条目聚类为高级抽象单元。Memory-R1 引入配备专用"记忆管理器"工具的辅助 Agent 处理记忆更新。但当前方案仍受限：多数由手动规则驱动，或针对狭窄任务特定目标优化，难以泛化到开放式设置。

**未来方向**：
- **工具调用集成**：通过显式工具调用将记忆构建、演化、检索直接集成到 Agent 决策循环，使 Agent 自身推理记忆操作而非依赖外部模块。LLM Agent 可精确知道执行的记忆动作（添加/更新/删除/检索），产生更连贯、透明、上下文基础的记忆行为。
- **自优化记忆结构**：采用受认知系统启发的分层和自适应架构。分层记忆结构提高效率和性能。自演化记忆系统动态链接、索引、重建记忆条目，使记忆存储随时间自组织，支持更丰富推理并减少对手工设计规则的依赖。


<br>

### 强化学习与记忆管理

**演进轨迹**：RL 正在重塑基于 LLM 的 Agent 开发范式，在规划、推理、工具使用等能力及数学推理、深度研究、软件工程等任务领域发挥核心作用。记忆作为基础组件，遵循从基于管道到模型原生范式的转变，从早期启发式和手动设计转向 RL 主导关键决策。

**RL-free 系统**：依赖启发式或手动指定机制，如固定阈值规则、严格语义搜索管道（MemOS、Mem0、MemoBase）、简单拼接策略。某些系统 LLM 看似 Agent 化参与记忆管理，但底层完全由提示驱动，未接受专门训练（Dynamic Cheatsheet、ExpeL、EvolveR、G-Memory）。这类方法主导早期工作，因简单性和可访问性仍具影响力。

**RL-assisted 系统**：将 RL 方法纳入记忆管道选定组件。RMM 采用轻量级策略梯度学习器在初始检索后对记忆块排序。Mem-α 将记忆构建全过程委托给 RL 训练的 Agent，Memory-R1 采用类似理念。工作记忆管理方面，Context Folding、Memory-as-Action、MemSearcher、IterResearch 等用 RL 训练，在超长多轮任务中自主折叠、压缩、管理上下文。

**完全 RL 驱动系统**：
- **最小化人工先验**：现有框架继承人类认知启发的设计模式（皮质/海马类比、预定义分层分类法），可能不代表人工 Agent 最有效结构。完全 RL 驱动使 Agent 发明新颖记忆组织，从优化动态中涌现而非人类直觉，通过 RL 激励设计新记忆格式、存储模式、更新规则。
- **完全控制**：当前 RL-assisted 方法只干预记忆生命周期子集（Mem-α 自动化写作但依赖手动检索管道，MemSearcher 关注短期工作记忆未解决长期巩固）。完全 Agent 化系统要求 Agent 以集成方式自主处理多粒度记忆形成、演化、检索，需要端到端 RL 训练协调长时间范围内的复杂交互。

记忆将成为通过 RL 与 Agent 共同演化的完全可学习和自组织的子系统，而非附加的辅助机制。


<br>

### 多模态记忆

**背景**：随着文本记忆研究成熟和多模态大语言模型进步，注意力扩展到多模态记忆。现实世界 Agent 设置本质多模态，仅文本记忆系统不足以支持复杂环境中的长期推理和交互。

**两个方向**：
- **多模态 Agent 记忆**：使多模态 Agent 存储、检索、利用来自多样化感官输入的记忆（图像、音频、视频等非文本信号）。视觉模态受最多关注，支持视觉基础、时间跟踪、长期场景一致性等任务。音频和其他模态记忆系统相对未充分探索。
- **统一模型的记忆组件**：记忆用于增强多模态生成和一致性而非支持 Agent 决策。图像和视频生成系统中，记忆机制保持实体一致性、跨帧维护世界状态、确保长生成范围连贯性。记忆作为稳定结构将生成锚定到先前内容。

**未来挑战**：多模态记忆将成为 Agent 系统不可或缺组件，信息源本质多模态（感知、动作、环境反馈）。目前没有系统提供真正全模态支持，多数方法专门针对单个模态或模态间松散耦合。需设计灵活适应多样化模态同时保持语义对齐和时间连贯性的记忆表示和操作。多模态记忆需超越被动存储，支持抽象、跨模态推理、长期适应。


<br>

### 多 Agent 系统中的共享记忆

**演进**：共享记忆是实现协调、一致性、集体智能的关键机制。早期框架依赖孤立本地记忆与显式消息传递，Agent 通过对话历史或任务特定通信协议交换信息，虽避免直接干扰但遭受冗余、碎片化上下文、高通信开销，随团队规模和任务范围增加问题加剧。

**中心化共享记忆**：引入全局向量存储、黑板系统、共享文档等中心化结构，所有 Agent 可访问。实现团队级记忆，支持联合注意力、减少重复、促进长期协调，作为规划、角色交接、共识构建的持久共同基础。但天真的全局共享暴露新挑战：记忆混乱、写入争用、缺乏基于角色或权限的访问控制。

**未来方向**：
- **Agent 感知共享记忆**：读写行为以 Agent 角色、专业知识、信任为条件，实现更结构化和可靠的知识聚合。
- **学习驱动管理**：训练 Agent 基于长期团队性能决定何时、什么、如何贡献到共享记忆，而非依赖手工设计的同步、摘要、冲突解决策略。
- **跨模态抽象**：在开放式多模态环境中，共享记忆需支持跨异构信号抽象同时保持时间和语义连贯性，潜在记忆展现有前景路径。

<br>

### 世界模型的记忆

**核心目标**：构建高保真模拟物理世界的内部环境，生成无限可扩展且实时交互的内容。世界模型以迭代方式操作，每步接收动作并预测下一状态提供连续反馈，不同于创建固定长度剪辑的传统视频生成。

**记忆机制作用**：存储维护前一时间步的空间和语义信息或隐藏状态，确保下一块生成在场景布局、对象属性、运动逻辑方面与先前上下文保持长期一致性，使世界模型处理长期时间依赖并实现可信模拟交互。

**早期方法局限**：
- **帧采样**：将生成条件化在几个历史帧上，导致上下文碎片化和感知漂移，早期细节丢失。
- **滑动窗口**：采用注意力汇和本地 KV Cache等技术，虽解决计算瓶颈但将记忆限制在固定窗口内，对象离开视图即被遗忘，阻止循环闭合等复杂任务。

**当前架构**（2025 年底转向结构化状态表示）：
- **状态空间模型（SSMs）**：Long-Context SSMs 利用 Mamba 风格骨干，将无限历史压缩为固定大小递归状态，实现理论上无限记忆容量同时保持恒定推理成本。
- **显式记忆库**：维护历史表示的外部存储支持精确召回。UniWM 采用分层设计，通过基于特征的相似度门控分离短期感知与长期历史。WorldMem 和 Context-as-Memory（CaM）维护过去上下文的平面库，利用几何检索（FOV 重叠）动态选择相关帧保持 3D 场景一致性。
- **稀疏记忆和检索**：Genie Envisioner 和 Ctrl World 利用稀疏记忆机制平衡长期一致性与效率，通过注入稀疏采样历史帧或检索姿态条件上下文增强当前观察，锚定预测并防止操作任务期间的漂移。

**未来方向**：
- **双系统架构**：受认知科学启发，分叉为快速和慢速组件。系统 1 使用 SSMs 等高效骨干处理即时物理和流畅交互，系统 2 使用大规模 VLMs 或显式记忆数据库处理复杂推理、规划、世界一致性。
- **主动记忆管理**：被动机制被主动记忆策略取代，设计为认知工作空间，基于任务相关性主动策划、摘要、丢弃信息，而非盲目存储最近历史的固定缓冲区。主动记忆管理在处理功能无限上下文方面显著优于静态检索方法，从记住最后 N 个 token 转变为维护连贯和可查询的世界状态。

<br>

### 可信记忆

**背景**：记忆支持持久性、个性化、持续学习，但随着记忆系统深入嵌入 Agent，可信性至关重要。早期 RAG 系统中幻觉和事实性担忧演化为记忆增强 Agent 的更广泛信任讨论。Agent 记忆存储用户特定、持久、潜在敏感内容（事实知识、交互历史、偏好、行为痕迹），引入隐私、可解释性、安全性挑战。

**关键问题**：
- **记忆泄露**：记忆模块可能通过间接基于提示的攻击泄露私人数据，记忆化和过度保留存在风险。
- **访问控制**：需支持显式访问控制、可验证遗忘、可审计更新机制。
- **可解释性瓶颈**：用户和开发者缺乏工具追踪检索了哪些记忆项、如何影响生成、是否被误用。RAGChecker、RAMDocs with MADAM-RAG 等诊断工具和冲突解决框架提供灵感。
- **集体隐私**：共享或联邦记忆系统中集体隐私的重要性，在多 Agent 部署或组织间操作中尤为突出。

**技术方案**：

**事实性保证**：
- **引用溯源**：记录记忆来源、置信度、支持证据。
- **事实核查**：存储前提取声明、验证知识库、检查与现有记忆一致性、分配置信度、存储验证元数据。
- **置信度评分**：基于来源可靠性、支持证据数量、与其他记忆一致性、时效性计算。

**可解释性**：
- **使用日志**：记录时间戳、查询、检索记忆、推理过程、最终决策。
- **注意力可视化**：显示记忆各部分重要性。
- **解释生成**：LLM 生成解释说明为何检索特定记忆。

**鲁棒性**：
- **攻击类型**：记忆污染（注入错误记忆）、对抗检索（构造查询导致检索错误记忆）、数据篡改。
- **防御措施**：对抗训练、输入验证（格式验证、可疑模式检查、来源真实性验证、内容清理）、异常检测（监控异常记忆模式、可疑检索模式、意外更新）。

**伦理与隐私**：
- **用户控制**：查看、编辑、删除记忆，控制记忆内容，选择退出记忆收集。
- **隐私保护技术**：差分隐私、联邦学习、同态加密、数据最小化。
- **偏见缓解**：定期偏见审计、多样化训练数据、公平性约束、偏见检测和纠正。
- **合规性**：GDPR、CCPA 合规，自动数据删除，同意管理。

**未来方向**：
- **隐私保护**：细粒度权限记忆、用户管理保留策略、加密或设备上存储、联邦访问。差分隐私、记忆编辑、自适应遗忘（基于衰减模型、用户擦除接口）防止记忆化和泄露。
- **可解释性增强**：可追踪访问路径、自理性检索、反事实推理（如果没有这个记忆会发生什么）。记忆注意力可视化、记忆影响因果图、面向用户的调试工具成为标准组件。
- **幻觉缓解**：冲突检测、多文档推理、不确定性感知生成。低置信度检索下弃权、回退模型先验、多 Agent 交叉检查。机制可解释性技术分析内部表示和推理电路如何导致幻觉输出，表示级探测、推理路径分解提供细粒度诊断和干预控制工具。
- **系统级抽象**：类似操作系统的记忆管理，分段、版本控制、可审计，Agent 和用户共同管理。

<br>

### 人类认知连接

**结构对齐**：当代 Agent 记忆系统架构与人类认知基础模型汇聚。容量受限上下文窗口与大规模外部向量数据库耦合，反映 Atkinson-Shiffrin 多存储模型，实例化工作记忆和长期记忆区别。Agent 记忆划分为交互日志、世界知识、基于代码的技能，与 Tulving 的情景、语义、程序记忆分类表现出显著结构对齐。当前框架将这些生物类别操作化为工程产物，情景记忆提供自传连续性，语义记忆提供泛化世界知识。

**动态分歧**：尽管结构相似，检索和维护动态方面存在根本分歧。人类记忆作为构建过程，大脑基于当前认知状态主动重建过去事件而非重放精确记录。现有 Agent 记忆系统依赖逐字检索机制（RAG），将记忆视为不可变 token 仓库，通过语义相似度查询。Agent 拥有过去真实记录，但缺乏记忆扭曲、抽象、动态重塑历史的能力，这些能力表征人类智能。

**未来方向**：
- **离线巩固机制**：纳入类似生物睡眠的离线巩固，超越纯粹在线更新。借鉴互补学习系统（CLS）理论，引入专门巩固间隔，Agent 与环境交互解耦，参与记忆重组和生成式重放。离线期间自主从原始情景痕迹提炼可泛化模式，执行主动遗忘修剪冗余噪声，在没有实时处理延迟约束下优化内部索引。
- **生成式重建**：从显式文本检索转向生成式重建。利用生成式记忆，Agent 按需合成潜在记忆 token，反映大脑重建性质。整合类似睡眠的巩固周期，Agent 从归档数据实体演化为内化经验实体，通过定期将大量情景流压缩为高效参数化直觉解决稳定性-可塑性困境。

<br>

### 核心洞见与未来方向

#### 核心洞见

**记忆是 Agent 认知跃迁的关键**：从"反应式"到"认知式"，记忆系统使 Agent 能够个性化、提升效率、保持一致性、持续学习。

**Forms–Functions–Dynamics 三维协同**：三个维度必须协同设计，孤立优化任一维度效果有限。Forms 决定 Functions，Functions 影响 Dynamics，Dynamics 优化 Forms。

**当前局限**：主流方法依赖人工设计、静态架构、单一形式。未来方向是自动化、自适应、混合架构。

#### 研究趋势

**技术趋势**：
- **自动化与自适应**：从人工设计转向自动发现和优化记忆架构（Meta-learning、NAS、RL）
- **多模态扩展**：从文本记忆扩展到图像、音频、视频等多模态记忆
- **可信性增强**：关注事实性、可解释性、鲁棒性、隐私保护
- **大规模部署**：从研究原型转向生产环境部署（分布式系统、边缘计算）

**应用趋势**：
- **领域扩展**：从对话系统扩展到具身智能、AR/VR、多 Agent 协作、边缘设备
- **用户参与**：从黑盒系统转向透明、可控、可修正的记忆系统

#### 未来建议

**研究建议**：
1. **建立综合 Benchmark**：覆盖存储、检索、更新、遗忘全生命周期的评估框架
2. **开发轻量动态机制**：适用于边缘设备的记忆系统（模型压缩、高效检索、增量更新）
3. **人本记忆设计**：透明性、可控性、可修正性，让用户参与记忆管理
4. **神经符号融合**：结合 LLM 灵活性与符号系统可验证性（混合架构、符号引导、神经执行）

**工程建议**：
1. **模块化设计**：记忆系统作为独立模块，标准化接口，支持插件扩展
2. **性能优化**：缓存策略、异步处理、批量操作
3. **监控与调试**：记忆使用监控、性能指标跟踪、调试工具
4. **安全与隐私**：数据加密、访问控制、审计日志

<br>



<br>

## 6. 资源与框架

### Benchmark

#### 专为记忆设计的基准

##### AgentBoard（Zhou et al., 2024）

**特点**：
- **多任务场景**：涵盖对话、任务规划、工具使用等多种任务类型
- **长期交互**：模拟长期用户-Agent 交互（数周至数月）
- **用户模拟**：使用模拟用户生成多样化的交互模式
- **记忆显式评估**：直接测试记忆的保留、检索、更新能力

**评估指标**：
- **记忆保留率（Memory Retention Rate）** ：长期记忆的保留比例
- **个性化准确率（Personalization Accuracy）** ：Agent 行为与用户偏好的匹配度
- **检索精度（Retrieval Precision）** ：检索到的记忆与查询的相关性
- **一致性（Consistency）** ：Agent 在不同时间对同一用户的行为一致性

**任务示例**：
```
Task: Personal Assistant
- Day 1: User says "I prefer morning meetings"
- Day 10: User asks "Schedule a meeting"
- Expected: Agent should schedule in the morning
- Evaluation: Does agent remember the preference?
```

<br>

##### MemBench（Memory Benchmark）

**特点**：
- **显式测试记忆 CRUD 操作**：Create、Read、Update、Delete
- **覆盖记忆全生命周期**：从存储到检索到更新到遗忘
- **多记忆形式支持**：Episodic、Semantic、Procedural

**评估指标**：
- **检索精度（Retrieval Precision）** ：Recall@K、Precision@K、MRR
- **更新一致性（Update Consistency）** ：更新后记忆的一致性
- **遗忘合规性（Forgetting Compliance）** ：遗忘策略的正确性
- **冲突解决（Conflict Resolution）** ：新旧记忆冲突的处理能力

**测试场景**：
```
Scenario 1: Memory Creation
  - Store: "User prefers coffee"
  - Test: Can retrieve this memory?

Scenario 2: Memory Update
  - Old: "User prefers coffee"
  - New: "User now prefers tea"
  - Test: Is memory updated correctly?

Scenario 3: Memory Deletion
  - Store then delete: "Temporary note"
  - Test: Is memory deleted? Can it be retrieved?
```

<br>


##### LifelongQA（持续问答基准）

**特点**：
- **持续学习**：Agent 需要从持续到来的问题中学习
- **知识累积**：测试知识随时间累积的效果
- **遗忘测试**：测试长期记忆的保留能力

**评估指标**：
- **回答正确率随时间变化曲线**：学习曲线
- **知识保留率**：旧知识的记忆保留情况
- **新知识整合能力**：新知识的快速学习能力

**数据集**：
- 时间跨度：数月至数年
- 问题类型：事实性、推理性、多跳推理
- 知识领域：通用知识、领域特定知识

<br>

#### 通用 Agent 基准（隐含记忆需求）

这些基准虽未显式标注"memory"，但其特性天然要求强大的记忆系统：

##### WebArena（Zhou et al., 2023）

**特点**：
- **长周期网页操作**：需要执行多步骤、长时间的任务
- **状态管理**：需要记住之前的操作和状态
- **上下文依赖**：后续操作依赖前面的操作结果

**记忆需求**：
- **工作记忆压缩**：长序列任务需要压缩中间步骤
- **状态记忆**：记住当前任务的状态和进度
- **操作历史**：记录操作序列，支持错误回溯

**示例任务**：
```
Task: Book a flight
Steps:
  1. Search flights (NYC → LAX)
  2. Filter by preferences (direct, morning)
  3. Select flight
  4. Enter passenger info
  5. Confirm booking

Memory needed: Remember preferences, selected flight, 
               passenger info across steps
```

<br>


##### AgentBench（Liu et al., 2024）

**特点**：
- **工具使用**：测试 Agent 调用外部工具的能力
- **多步推理**：需要多步骤的推理和规划
- **任务多样性**：涵盖代码生成、数据分析、网页操作等

**记忆需求**：
- **程序记忆复用**：复用成功的工具调用模式
- **案例检索**：检索相似的历史任务案例
- **错误记忆**：记住失败的操作，避免重复错误


<br>

##### GAIA（Mialon et al., 2024）

**特点**：
- **真实世界问题**：需要整合来自多个来源的信息
- **多文档推理**：需要跨文档的记忆整合
- **长期依赖**：问题可能依赖之前的知识

**记忆需求**：
- **跨文档记忆整合**：整合来自多个文档的信息
- **知识图谱构建**：构建跨文档的知识图谱
- **长期知识保留**：保留之前学到的知识

<br>

#### 基准对比总结

| 基准 | 记忆显式性 | 时间跨度 | 主要评估维度 | 适用场景 |
|------|-----------|---------|------------|---------|
| **AgentBoard** | 显式 | 长期（周-月） | 保留、个性化、一致性 | 长期交互 Agent |
| **MemBench** | 显式 | 短期 | CRUD 操作、更新、遗忘 | 记忆系统开发 |
| **LifelongQA** | 显式 | 长期（月-年） | 知识累积、保留 | 持续学习系统 |
| **WebArena** | 隐含 | 短期（单任务） | 工作记忆、状态管理 | 网页操作 Agent |
| **AgentBench** | 隐含 | 短期（单任务） | 程序记忆、案例检索 | 通用 Agent |
| **GAIA** | 隐含 | 短期（单任务） | 跨文档整合 | 知识问答 |



<br>

### 开源框架与工具

#### 框架概览

##### G-Memory（Zhang et al., 2025c）

**核心创新**：
- **多 Agent 个性化记忆**：为每个 Agent 维护独立的记忆空间
- **图结构存储**：使用知识图谱组织记忆
- **角色特定提示**：将通用记忆转换为角色特定的 prompt

**技术栈**：
- **存储**：Neo4j 图数据库
- **检索**：Cypher 查询语言 + 向量相似性搜索
- **个性化**：LLM-based role prompting

**使用场景**：
- 多 Agent 协作系统
- 需要个性化记忆的场景
- 复杂关系查询需求

**示例**：
```python
# G-Memory 使用示例
memory = GMemory(user_id="U123", agent_role="medical_assistant")

# 存储记忆
memory.store(
    fact="User is a doctor",
    context="medical"
)

# 检索时，自动转换为角色特定提示
prompt = memory.retrieve_as_prompt(query="user background")
# Output: "The user is a medical professional (doctor), 
#          emphasize accuracy and evidence-based responses"
```

<br>

##### MA-RAG（Multi-Agent RAG, Nguyen et al., 2025）

**核心创新**：
- **检索后细粒度提取**：使用多个 Agent 对检索结果进行精细处理
- **查询分解**：将复杂查询分解为子查询
- **多 Agent 协作**：不同 Agent 负责不同的处理任务

**技术架构**：
```
Query → Query Decomposer Agent
      ↓
      [Sub-query 1, Sub-query 2, ...]
      ↓
      Retrieval (for each sub-query)
      ↓
      Extractor Agent (for each result)
      ↓
      Integration Agent
      ↓
      Final Context
```

**优势**：
- **精确提取**：只提取最相关的信息片段
- **减少噪声**：过滤掉不相关的检索结果
- **结构化输出**：输出结构化的上下文

<br>

##### ComoRAG（Wang et al., 2025f）

**核心创新**：
- **全局上下文整合**：Integration Agent 对多个检索文档进行语义对齐
- **Broad Contextual Grounding**：生成统一的、广泛的上下文摘要
- **避免信息碎片化**：将分散的信息整合为连贯的上下文

**技术流程**：
```
Multiple Retrieved Documents
    ↓
Integration Agent:
  - Semantic alignment
  - Cross-document reasoning
  - Unified summary generation
    ↓
Broad Contextual Grounding
    ↓
LLM with enriched context
```

**应用场景**：
- 需要整合多个来源信息的任务
- 复杂推理任务
- 知识问答系统

<br>


##### Matrix（Liu et al., 2024）

**核心创新**：
- **经验提炼为原则**：从 Agent 轨迹中提炼任务无关原则
- **迭代反思循环**：多轮迭代优化原则质量
- **原则驱动决策**：使用提炼的原则指导 Agent 行为

**技术流程**：
```
Agent Trajectories
    ↓
Reflection Loop:
  Round 1: Initial principle extraction
  Round 2: Refinement
  Round 3: Validation
  ...
    ↓
Task-agnostic Principles
    ↓
Principle-guided Agent Behavior
```

**优势**：
- **高度抽象**：原则可跨任务复用
- **持续改进**：通过迭代优化原则质量
- **可解释性**：原则提供决策的可解释性

<br>

#### 检索后处理（Post-Retrieval Processing）关键技术

**核心问题**：原始检索结果常**冗余、噪声大、缺乏结构**，需要后处理才能有效利用。
- **记忆质量 = 检索质量 × 后处理能力**。优秀的记忆系统不仅需要高效的检索，更需要智能的后处理来提取、整合、个性化记忆。

##### Query Decomposition（查询分解）

**方法**（MA-RAG）：
```
Complex Query: "What are the user's preferences for flights and hotels?"

Decomposed:
  - Sub-query 1: "User's flight preferences"
  - Sub-query 2: "User's hotel preferences"

For each sub-query:
  - Retrieve relevant memories
  - Extract most relevant snippets
  - Combine results
```

**优势**：
- **精确匹配**：每个子查询更精确，检索结果更相关
- **并行处理**：可以并行处理多个子查询
- **模块化**：便于组合和复用

<br>

##### Semantic Alignment（语义对齐）

**方法**（ComoRAG）：
```
Retrieved Documents:
  Doc 1: "User prefers direct flights"
  Doc 2: "User likes non-stop flights"
  Doc 3: "User booked direct flight NYC→LAX"

Semantic Alignment:
  - Recognize "direct" = "non-stop"
  - Align temporal information
  - Identify core concept: "prefers direct flights"

Unified Summary:
  "User consistently prefers direct/non-stop flights, 
   as evidenced by multiple bookings and stated preferences"
```

**技术实现**：
- **实体对齐**：识别不同文档中的相同实体
- **关系对齐**：识别相同的关系模式
- **时间对齐**：整合时间序列信息

<br>

##### Role-Specific Prompting（角色特定提示）

**方法**（G-Memory）：
```
Generic Memory: "User is a doctor"

For Medical Agent:
  Prompt: "The user is a medical professional (doctor). 
           Emphasize accuracy, evidence-based responses, 
           and use appropriate medical terminology."

For Customer Service Agent:
  Prompt: "The user is a doctor (medical professional). 
           They likely have limited time and value efficiency. 
           Be concise and respect their time constraints."
```

**优势**：
- **上下文适应**：同一记忆在不同上下文中发挥不同作用
- **个性化**：根据 Agent 角色定制记忆的使用方式
- **灵活性**：支持多 Agent 系统中的个性化


<br>

##### Reranking（重排序）

**方法**：
```
Initial Retrieval (Top 20):
  [Result 1, Result 2, ..., Result 20]

Cross-Encoder Reranking:
  For each (query, result) pair:
    score = cross_encoder(query, result)
  
  Sort by score
  Return Top 5
```

**优势**：
- **提高精度**：交叉编码器比双编码器更准确
- **考虑交互**：直接建模查询和结果的交互

**劣势**：
- **计算成本**：需要为每个候选结果计算，成本高
- **延迟**：增加检索延迟


<br>

##### Deduplication（去重）

**方法**：
```
Retrieved Results:
  Result 1: "User prefers direct flights"
  Result 2: "User likes non-stop flights"  # Similar
  Result 3: "User booked flight NYC→LAX"

Deduplication:
  - Calculate similarity between results
  - If similarity > threshold (e.g., 0.95):
      Keep most detailed version
      Remove duplicates
```

**实现**：
- **向量相似度**：使用嵌入计算相似度
- **文本相似度**：使用编辑距离、Jaccard 相似度
- **语义相似度**：使用 LLM 判断语义等价性
<br>

#### 其他框架

##### LangChain Memory

**特点**：
- **多种记忆后端**：支持向量数据库、SQL、内存等
- **易于集成**：与 LangChain 生态无缝集成
- **灵活配置**：支持多种记忆配置

**使用示例**：
```python
from langchain.memory import VectorStoreRetrieverMemory
from langchain.vectorstores import FAISS

vectorstore = FAISS.from_texts(["..."])
memory = VectorStoreRetrieverMemory(
    retriever=vectorstore.as_retriever()
)
```
<br>

##### LlamaIndex

**特点**：
- **高级检索策略**：子查询分解、时间加权检索等
- **多模态支持**：支持文本、图像等多模态记忆
- **可扩展性**：支持大规模记忆库

<br>

##### Mem0

**特点**：
- **自动记忆提取**：从对话中自动提取记忆
- **向量检索**：使用向量数据库进行高效检索
- **用户友好**：提供简单的 API
<br>



<br>

## 7. 未来展望

<br>

### 记忆检索到记忆生成

**范式转变**：传统方法以记忆检索为中心，通过索引策略、相似度度量、重排序模型或知识图谱提高检索准确性。技术包括密集嵌入向量搜索、混合检索（词汇+语义）、分层过滤、图遍历。这些方法强调精确率和召回率，隐含假设记忆库已形成良好。

**生成式记忆**：不是将记忆视为静态仓库，而是 Agent 主动按需合成新记忆表示。目标不仅是检索拼接，而是整合、压缩、重组信息以适应上下文和未来效用。有效记忆使用需要抽象和重组，特别是当原始信息存在噪声、冗余或与任务不对齐时。

**两类方法**：
- **检索后生成**：ComoRAG、G-Memory、CoMEM 先检索相关记忆子集，再生成简洁、连贯、上下文特定的精炼表示，保持历史信息基础的同时支持自适应摘要和重组。
- **直接记忆生成**：MemGen、VisMem 直接从当前上下文、交互历史或潜在内部状态生成记忆表示，构建任务定制的潜在记忆 token，完全绕过显式记忆查找。

**未来方向**：
- **上下文自适应**：生成针对 Agent 预期未来需求优化的表示，使记忆粒度、抽象级别、语义焦点适应不同任务、问题解决阶段或交互机制。
- **跨异构信号整合**：将文本、代码、工具输出、环境反馈等碎片化信号融合为统一表示，潜在记忆可能是实现路径。
- **学习且自优化**：通过强化学习或长期任务性能学习何时及如何生成记忆，使记忆生成成为 Agent 策略组成部分，与推理和决策共同演化。

<br>

### 自动化记忆管理

**现状问题**：现有系统（MemOS、Mem0、MemoBase）依赖手动设计策略确定存储内容、使用时机、更新检索方式。通过详细指令、预定义阈值、人工规则指导固定 LLM，虽能快速原型部署且提供可解释性，但本质上不灵活，难以在多样化动态环境中泛化，长期或开放式交互表现不佳。

**初步进展**：CAM 使 LLM Agent 自动将细粒度记忆条目聚类为高级抽象单元。Memory-R1 引入配备专用"记忆管理器"工具的辅助 Agent 处理记忆更新。但当前方案仍受限：多数由手动规则驱动，或针对狭窄任务特定目标优化，难以泛化到开放式设置。

**未来方向**：
- **工具调用集成**：通过显式工具调用将记忆构建、演化、检索直接集成到 Agent 决策循环，使 Agent 自身推理记忆操作而非依赖外部模块。LLM Agent 可精确知道执行的记忆动作（添加/更新/删除/检索），产生更连贯、透明、上下文基础的记忆行为。
- **自优化记忆结构**：采用受认知系统启发的分层和自适应架构。分层记忆结构提高效率和性能。自演化记忆系统动态链接、索引、重建记忆条目，使记忆存储随时间自组织，支持更丰富推理并减少对手工设计规则的依赖。


<br>

### 强化学习与记忆管理

**演进轨迹**：RL 正在重塑基于 LLM 的 Agent 开发范式，在规划、推理、工具使用等能力及数学推理、深度研究、软件工程等任务领域发挥核心作用。记忆作为基础组件，遵循从基于管道到模型原生范式的转变，从早期启发式和手动设计转向 RL 主导关键决策。

**RL-free 系统**：依赖启发式或手动指定机制，如固定阈值规则、严格语义搜索管道（MemOS、Mem0、MemoBase）、简单拼接策略。某些系统 LLM 看似 Agent 化参与记忆管理，但底层完全由提示驱动，未接受专门训练（Dynamic Cheatsheet、ExpeL、EvolveR、G-Memory）。这类方法主导早期工作，因简单性和可访问性仍具影响力。

**RL-assisted 系统**：将 RL 方法纳入记忆管道选定组件。RMM 采用轻量级策略梯度学习器在初始检索后对记忆块排序。Mem-α 将记忆构建全过程委托给 RL 训练的 Agent，Memory-R1 采用类似理念。工作记忆管理方面，Context Folding、Memory-as-Action、MemSearcher、IterResearch 等用 RL 训练，在超长多轮任务中自主折叠、压缩、管理上下文。

**完全 RL 驱动系统**：
- **最小化人工先验**：现有框架继承人类认知启发的设计模式（皮质/海马类比、预定义分层分类法），可能不代表人工 Agent 最有效结构。完全 RL 驱动使 Agent 发明新颖记忆组织，从优化动态中涌现而非人类直觉，通过 RL 激励设计新记忆格式、存储模式、更新规则。
- **完全控制**：当前 RL-assisted 方法只干预记忆生命周期子集（Mem-α 自动化写作但依赖手动检索管道，MemSearcher 关注短期工作记忆未解决长期巩固）。完全 Agent 化系统要求 Agent 以集成方式自主处理多粒度记忆形成、演化、检索，需要端到端 RL 训练协调长时间范围内的复杂交互。

记忆将成为通过 RL 与 Agent 共同演化的完全可学习和自组织的子系统，而非附加的辅助机制。


<br>

### 多模态记忆

**背景**：随着文本记忆研究成熟和多模态大语言模型进步，注意力扩展到多模态记忆。现实世界 Agent 设置本质多模态，仅文本记忆系统不足以支持复杂环境中的长期推理和交互。

**两个方向**：
- **多模态 Agent 记忆**：使多模态 Agent 存储、检索、利用来自多样化感官输入的记忆（图像、音频、视频等非文本信号）。视觉模态受最多关注，支持视觉基础、时间跟踪、长期场景一致性等任务。音频和其他模态记忆系统相对未充分探索。
- **统一模型的记忆组件**：记忆用于增强多模态生成和一致性而非支持 Agent 决策。图像和视频生成系统中，记忆机制保持实体一致性、跨帧维护世界状态、确保长生成范围连贯性。记忆作为稳定结构将生成锚定到先前内容。

**未来挑战**：多模态记忆将成为 Agent 系统不可或缺组件，信息源本质多模态（感知、动作、环境反馈）。目前没有系统提供真正全模态支持，多数方法专门针对单个模态或模态间松散耦合。需设计灵活适应多样化模态同时保持语义对齐和时间连贯性的记忆表示和操作。多模态记忆需超越被动存储，支持抽象、跨模态推理、长期适应。


<br>

### 多 Agent 系统中的共享记忆

**演进**：共享记忆是实现协调、一致性、集体智能的关键机制。早期框架依赖孤立本地记忆与显式消息传递，Agent 通过对话历史或任务特定通信协议交换信息，虽避免直接干扰但遭受冗余、碎片化上下文、高通信开销，随团队规模和任务范围增加问题加剧。

**中心化共享记忆**：引入全局向量存储、黑板系统、共享文档等中心化结构，所有 Agent 可访问。实现团队级记忆，支持联合注意力、减少重复、促进长期协调，作为规划、角色交接、共识构建的持久共同基础。但天真的全局共享暴露新挑战：记忆混乱、写入争用、缺乏基于角色或权限的访问控制。

**未来方向**：
- **Agent 感知共享记忆**：读写行为以 Agent 角色、专业知识、信任为条件，实现更结构化和可靠的知识聚合。
- **学习驱动管理**：训练 Agent 基于长期团队性能决定何时、什么、如何贡献到共享记忆，而非依赖手工设计的同步、摘要、冲突解决策略。
- **跨模态抽象**：在开放式多模态环境中，共享记忆需支持跨异构信号抽象同时保持时间和语义连贯性，潜在记忆展现有前景路径。

<br>

### 世界模型的记忆

**核心目标**：构建高保真模拟物理世界的内部环境，生成无限可扩展且实时交互的内容。世界模型以迭代方式操作，每步接收动作并预测下一状态提供连续反馈，不同于创建固定长度剪辑的传统视频生成。

**记忆机制作用**：存储维护前一时间步的空间和语义信息或隐藏状态，确保下一块生成在场景布局、对象属性、运动逻辑方面与先前上下文保持长期一致性，使世界模型处理长期时间依赖并实现可信模拟交互。

**早期方法局限**：
- **帧采样**：将生成条件化在几个历史帧上，导致上下文碎片化和感知漂移，早期细节丢失。
- **滑动窗口**：采用注意力汇和本地 KV Cache等技术，虽解决计算瓶颈但将记忆限制在固定窗口内，对象离开视图即被遗忘，阻止循环闭合等复杂任务。

**当前架构**（2025 年底转向结构化状态表示）：
- **状态空间模型（SSMs）**：Long-Context SSMs 利用 Mamba 风格骨干，将无限历史压缩为固定大小递归状态，实现理论上无限记忆容量同时保持恒定推理成本。
- **显式记忆库**：维护历史表示的外部存储支持精确召回。UniWM 采用分层设计，通过基于特征的相似度门控分离短期感知与长期历史。WorldMem 和 Context-as-Memory（CaM）维护过去上下文的平面库，利用几何检索（FOV 重叠）动态选择相关帧保持 3D 场景一致性。
- **稀疏记忆和检索**：Genie Envisioner 和 Ctrl World 利用稀疏记忆机制平衡长期一致性与效率，通过注入稀疏采样历史帧或检索姿态条件上下文增强当前观察，锚定预测并防止操作任务期间的漂移。

**未来方向**：
- **双系统架构**：受认知科学启发，分叉为快速和慢速组件。系统 1 使用 SSMs 等高效骨干处理即时物理和流畅交互，系统 2 使用大规模 VLMs 或显式记忆数据库处理复杂推理、规划、世界一致性。
- **主动记忆管理**：被动机制被主动记忆策略取代，设计为认知工作空间，基于任务相关性主动策划、摘要、丢弃信息，而非盲目存储最近历史的固定缓冲区。主动记忆管理在处理功能无限上下文方面显著优于静态检索方法，从记住最后 N 个 token 转变为维护连贯和可查询的世界状态。

<br>

### 可信记忆

**背景**：记忆支持持久性、个性化、持续学习，但随着记忆系统深入嵌入 Agent，可信性至关重要。早期 RAG 系统中幻觉和事实性担忧演化为记忆增强 Agent 的更广泛信任讨论。Agent 记忆存储用户特定、持久、潜在敏感内容（事实知识、交互历史、偏好、行为痕迹），引入隐私、可解释性、安全性挑战。

**关键问题**：
- **记忆泄露**：记忆模块可能通过间接基于提示的攻击泄露私人数据，记忆化和过度保留存在风险。
- **访问控制**：需支持显式访问控制、可验证遗忘、可审计更新机制。
- **可解释性瓶颈**：用户和开发者缺乏工具追踪检索了哪些记忆项、如何影响生成、是否被误用。RAGChecker、RAMDocs with MADAM-RAG 等诊断工具和冲突解决框架提供灵感。
- **集体隐私**：共享或联邦记忆系统中集体隐私的重要性，在多 Agent 部署或组织间操作中尤为突出。

**技术方案**：

**事实性保证**：
- **引用溯源**：记录记忆来源、置信度、支持证据。
- **事实核查**：存储前提取声明、验证知识库、检查与现有记忆一致性、分配置信度、存储验证元数据。
- **置信度评分**：基于来源可靠性、支持证据数量、与其他记忆一致性、时效性计算。

**可解释性**：
- **使用日志**：记录时间戳、查询、检索记忆、推理过程、最终决策。
- **注意力可视化**：显示记忆各部分重要性。
- **解释生成**：LLM 生成解释说明为何检索特定记忆。

**鲁棒性**：
- **攻击类型**：记忆污染（注入错误记忆）、对抗检索（构造查询导致检索错误记忆）、数据篡改。
- **防御措施**：对抗训练、输入验证（格式验证、可疑模式检查、来源真实性验证、内容清理）、异常检测（监控异常记忆模式、可疑检索模式、意外更新）。

**伦理与隐私**：
- **用户控制**：查看、编辑、删除记忆，控制记忆内容，选择退出记忆收集。
- **隐私保护技术**：差分隐私、联邦学习、同态加密、数据最小化。
- **偏见缓解**：定期偏见审计、多样化训练数据、公平性约束、偏见检测和纠正。
- **合规性**：GDPR、CCPA 合规，自动数据删除，同意管理。

**未来方向**：
- **隐私保护**：细粒度权限记忆、用户管理保留策略、加密或设备上存储、联邦访问。差分隐私、记忆编辑、自适应遗忘（基于衰减模型、用户擦除接口）防止记忆化和泄露。
- **可解释性增强**：可追踪访问路径、自理性检索、反事实推理（如果没有这个记忆会发生什么）。记忆注意力可视化、记忆影响因果图、面向用户的调试工具成为标准组件。
- **幻觉缓解**：冲突检测、多文档推理、不确定性感知生成。低置信度检索下弃权、回退模型先验、多 Agent 交叉检查。机制可解释性技术分析内部表示和推理电路如何导致幻觉输出，表示级探测、推理路径分解提供细粒度诊断和干预控制工具。
- **系统级抽象**：类似操作系统的记忆管理，分段、版本控制、可审计，Agent 和用户共同管理。

<br>

### 人类认知连接

**结构对齐**：当代 Agent 记忆系统架构与人类认知基础模型汇聚。容量受限上下文窗口与大规模外部向量数据库耦合，反映 Atkinson-Shiffrin 多存储模型，实例化工作记忆和长期记忆区别。Agent 记忆划分为交互日志、世界知识、基于代码的技能，与 Tulving 的情景、语义、程序记忆分类表现出显著结构对齐。当前框架将这些生物类别操作化为工程产物，情景记忆提供自传连续性，语义记忆提供泛化世界知识。

**动态分歧**：尽管结构相似，检索和维护动态方面存在根本分歧。人类记忆作为构建过程，大脑基于当前认知状态主动重建过去事件而非重放精确记录。现有 Agent 记忆系统依赖逐字检索机制（RAG），将记忆视为不可变 token 仓库，通过语义相似度查询。Agent 拥有过去真实记录，但缺乏记忆扭曲、抽象、动态重塑历史的能力，这些能力表征人类智能。

**未来方向**：
- **离线巩固机制**：纳入类似生物睡眠的离线巩固，超越纯粹在线更新。借鉴互补学习系统（CLS）理论，引入专门巩固间隔，Agent 与环境交互解耦，参与记忆重组和生成式重放。离线期间自主从原始情景痕迹提炼可泛化模式，执行主动遗忘修剪冗余噪声，在没有实时处理延迟约束下优化内部索引。
- **生成式重建**：从显式文本检索转向生成式重建。利用生成式记忆，Agent 按需合成潜在记忆 token，反映大脑重建性质。整合类似睡眠的巩固周期，Agent 从归档数据实体演化为内化经验实体，通过定期将大量情景流压缩为高效参数化直觉解决稳定性-可塑性困境。

<br>

### 核心洞见与未来方向

**核心洞见**：
- **记忆是 Agent 认知跃迁关键**：从反应式到认知式，记忆系统使 Agent 能够个性化、提升效率、保持一致性、持续学习。
- **Forms–Functions–Dynamics 三维协同**：三个维度必须协同设计，孤立优化任一维度效果有限。Forms 决定 Functions，Functions 影响 Dynamics，Dynamics 优化 Forms。
- **当前局限**：主流方法依赖人工设计、静态架构、单一形式。未来方向是自动化、自适应、混合架构。

**研究趋势**：
- **技术趋势**：自动化与自适应（Meta-learning、NAS、RL）、多模态扩展、可信性增强（事实性、可解释性、鲁棒性、隐私保护）、大规模部署（分布式系统、边缘计算）。
- **应用趋势**：领域扩展（具身智能、AR/VR、多 Agent 协作、边缘设备）、用户参与（透明、可控、可修正的记忆系统）。

**未来建议**：
- **研究**：建立综合 Benchmark（覆盖存储、检索、更新、遗忘全生命周期）、开发轻量动态机制（边缘设备适用，模型压缩、高效检索、增量更新）、人本记忆设计（透明性、可控性、可修正性）、神经符号融合（混合架构、符号引导、神经执行）。
- **工程**：模块化设计（独立模块、标准化接口、插件扩展）、性能优化（缓存策略、异步处理、批量操作）、监控与调试（使用监控、性能跟踪、调试工具）、安全与隐私（数据加密、访问控制、审计日志）。

<br>