---
title: CV(2)：卷积神经网络
date: 2024-02-13
categories:
  - 学AI/DS
tags:
  - CV
desc: CS231n Lec5 笔记，资料整合与一些自己的思考。卷积神经网络(卷积层、池化层、ReLU层、全连接层、局部连接、参数共享、最大池化、步长、零填充)。部分内容与NLP重合不过多赘述。

---

- 参考
    - <a href="https://www.showmeai.tech/article-detail/260">`showmeai-斯坦福CS231n教程`</a>


## 产生过程

1959年开始 ，Hubel & Wiesel 做了一些列实验，试图弄明白神经元如何在视觉皮层上工作。他们把电极放进猫的脑袋中，然后给猫不同的视觉刺激，比如不同的边缘方向、不同的形状等，然后测量神经元的应激响应。

他们得出一些重要的结论：一是大脑皮层上的细胞与视觉中的区域相关联，有映射关系。二是神经元间存在分层关系。初级层次的细胞对光的方向产生反应，复杂一点的会对光的移动有反应，超复杂的可以反应端点，识别形状。

1980年，Fukushima 的感知神经器首次将这种简单细胞与复杂细胞的概念形成实例，一种简单细胞与复杂细胞交替层结构。简单细胞会有一些可调参数，复杂细胞对简单细胞执行池化操作。

1998年，LeCun, Bottou, Bengio, Haffner等人首次展示一个实例，应用反向传播和基于梯度的学习方法来训练卷积神经网络，用于邮政编码识别，效果显著。但是有局限性，不能用到更复杂的数据中。

2012年，Alex 等人提出一种现代化的卷积神经网络，称为 AlexNet。与 LeCun 的很相似，只是更大更深，可以充分利用大量图片数据比如 Image net 和 GPU 并行计算能力。

今天，CNN已经被广泛应用到图像分类、目标检测、图像分割等。这些技术被广泛用于自动驾驶领域，使用GPU驱动，将高性能的 GPU 置于嵌入式系统。应用到其他领域，比如人脸识别、视频分类、姿势识别、医学影像分析、星系分类、路标识别，也应用到游戏中，比如 AlfaGo。除了分类识别等任务，还可用于图像描述、艺术创作（Deep Dream，神经图像风格迁移）。

<br>

## 详述

### 对比常规神经网络

**卷积神经网络（CNN / ConvNet）** 和常规神经网络非常相似：

- 都是由神经元组成，神经元中有具有学习能力的权重和偏置项。每个神经元都得到一些输入数据，进行内积运算后再进行激活函数运算；
- 整个网络依旧是一个可导的评分函数，该函数的输入是原始的图像像素，输出是不同类别的评分；
- 在最后一层（往往是全连接层），网络依旧有一个损失函数（比如 SVM 或 Softmax），并且在神经网络中我们实现的各种技巧和要点依旧适用于卷积神经网络。

卷积神经网络的结构基于输入数据是图像，向结构中添加了一些特有的性质，使得前向传播函数实现起来更高效，并且大幅度降低了网络中参数的数量。

#### 常规神经网络

常规神经网络的输入是一个向量，比如把一张 $32 \times 32 \times 3$ 的图片延展成 $3072 \times 1$ 的列向量 $x$，然后在一系列的隐层中对它做变换。

**每个隐层都是由若干的神经元组成，每个神经元都与前一层中的所有神经元连接（这就是全连接的概念）**。 但是在一个隐层中，神经元相互独立不进行任何连接。

最后的全连接层被称为「**输出层**」，在分类问题中，它输出的值被看做是不同类别的评分值。比如线性分类 $Wx$ ，$W$ 是 $10 \times 3072$ 的权重矩阵，即 $W$ 有 10 个行向量，最终输出是一个 $10 \times 1$ 的得分向量，其中的每一个值是 $W$ 的某一个行向量和 $x$ 的点积结果，也就是一个神经元的输出。

最终会有 $10$ 个神经元输出 $10$ 个值（ $W_0x, W_1x, \cdots, W_9x$），$x$ 和每一个神经元相连，因此是全连接的。

##### 缺点与限制

但是全连接神经网络在处理大的图片数据时参数会急速增加，同时效果也不尽如人意。

- 比如在 CIFAR-10 中，图像的尺寸是 $32 \times 32 \times 3$，对应网络的第一个隐层中，每一个单独的全连接神经元的参数个数即 $W$ 的一个行向量就有 $32 \times 32 \times 3=3072$ 个。
- 若是一个尺寸为 $200 \times 200 \times 3$ 的图像，会让神经元包含 $200 \times 200 \times 3=120,000$ 个权重值。而网络中肯定不止一个神经元，那么参数的量就会快速增加！

全连接方式效率不高，且参数量大，可能会导致网络过拟合。

#### 卷积神经网络

与常规神经网络不同，卷积神经网络的各层中的神经元都是 3 维的：**宽度、高度和深度**（这里的深度指的是激活数据体的第三个维度，而不是整个网络的深度，整个网络的深度指的是网络的层数）。

- 以第一层卷积层为例，输入数据仍然是 $32 \times 32 \times 3$（宽度 $\times$ 高度$\times$深度）的，并不会将其延展成一个列向量，这样可以保持图像的**空间结构**（spatial structure）。
- 与输入相连的神经元权重不再是 $W$ 的一个行向量（3072个参数），而是与输入数据有同样深度的**滤波器**（filter，也称作**卷积核**），比如是 $5 \times 5 \times 3$ 的滤波器 $w$。
- 这时的神经元（卷积核）不再与输入图像 $x$ 是全连接的，而是**局部连接**（local connectivity），只和 $x$ 中一个 $5 \times 5 \times 3$ 的小区域进行全连接（常规神经网络中每个神经元都和整个 $x$ 全连接），滤波器和这个区域计算一个点积 $wx$（计算的时候会展成两个向量进行点积），然后加一个偏置项 $b$，就得到一个输出数据（$wx+b$）。这样的一个神经元共有 $5 \times 5 \times 3+1=76$ 个参数。
- 这个滤波器会在 $x$ 上按一定的**步长**（stride） 依次滑动，比如步长为 $1$ 时，最终会得到一个 $28 \times 28 \times 1$ 的输出数据，称作**激活映射（activation map）** 或**特征映射（feature map）** ，对应 $28 \times 28$ 个神经元的输出。

对于用来分类 CIFAR-10 中图像的卷积网络，其最后的输出层的维度是 $1 \times 1 \times 10$，因为在卷积神经网络结构的最后部分将会把全尺寸的图像压缩为包含分类评分的一个向量，向量是在深度方向排列的。

上图左边是常规神经网络，每个神经元和上层的神经元都是全连接的；右图是卷积神经网络，每个神经元都有三个维度，网络每一层都将 3D 的输入数据变化为神经元 3D 的激活数据并输出。

在这个例子中，红色的输入层装的是图像，所以它的宽度和高度就是图像的宽度和高度，它的深度是3（代表了R/红、G/绿、B/蓝3个颜色通道）。

蓝色的部分是第一层卷积层的输出，这里的深度显然不为1，表明有多种滤波器。如果我们有 $6$ 个 $5 \times 5$ 的滤波器，每个卷积核代表从输入捕捉某些信息的滤波器，那它们依次滑过整张图片，得到第一个卷积层的输出结果是 $28 \times 28 \times 6$ 的。

<br>


## 结构
<img src="https://raw.githubusercontent.com/YukinoshitaSherry/qycf_picbed/main/img/20250715221819312.png" style="width:75%"><br>

一个简单的卷积神经网络是由各种层按照顺序排列组成，卷积神经网络主要由三种类型的层构成：**卷积层，池化（Pooling）层和全连接层**（全连接层和常规神经网络中的一样）。通过将这些层叠加起来，就可以构建一个完整的卷积神经网络。

一个用于 CIFAR-10 图像数据分类的卷积神经网络的结构可以是「**输入层-卷积层-ReLU层-池化层-全连接层**」，这四个层也是目前卷积神经网络比较常用的层。

- 输入层是 $[32 \times 32 \times 3]$ 存有图像的原始像素，本例中图像宽高均为 32，有3个颜色通道。
- 卷积层中，神经元与输入层中的一个局部区域相连，每个神经元都计算输入层上与自己相连的区域与自己权重的内积。卷积层会计算所有神经元的输出。如果使用12个滤波器（也叫作卷积核），得到的输出数据体的维度就是 $[32 \times 32 \times 12]$。
- ReLU层将会逐个元素地进行激活函数操作，比如使用以 $0$ 为阈值的ReLU函数 $\max(0,-)$ 作为激活函数。该层对数据尺寸没有改变，还是 $[32 \times 32 \times 12]$。
- 池化层在空间维度（宽度和高度）上进行**降采样**（downsampling）操作，假设数据尺寸变为 $[16 \times 16 \times 12]$。
- 全连接层将会计算分类评分，数据尺寸变为 $[1 \times 1 \times 10]$，其中 10 个数字对应的就是 CIFAR-10 中 10 个类别的分类评分值。全连接层与常规神经网络一样，其中每个神经元都与前一层中所有神经元相连接。

卷积神经网络一层一层地将图像从原始像素值变换成最终的分类评分值。

- 卷积层和全连接层（CONV/FC）对输入执行变换操作的时候，不仅会用到激活函数，还会用到很多参数（神经元的权值和偏置项）
- ReLU层和池化层进行一个固定的函数操作。
- 卷积层、全连接层和池化层有超参数，ReLU 层没有。卷积层和全连接层中的参数利用梯度下降训练。

实际应用的时候，卷积网络是由多个卷积层依次堆叠组成的序列，然后使用激活函数（比如ReLU函数）对其进行逐一处理。然后这些卷积层、激活层、池化层会依次堆叠，上一层的输出作为下一层的输入。每一层都会使用多个卷积核，每个卷积核对用一个激活映射。

卷积网络这些卷积层的所有卷积核完成训练后，会发现：
- 前面几个卷积层的卷积核捕捉和匹配的是一些比较简单的特征，比如边缘；
- 中间几层的卷积核代表的特征变得复杂一些，比如一些边角和斑点；
- 最后几层的特征就会变得特别丰富和复杂。

这些卷积核是从简单到复杂的特征序列。这实际上和 Hubel & Wiesel 的实验结果比较相似，即使在我们并没有明确的让网络去学习这些从简单到复杂的特征，但是给它这种层次结构并经过反向传播训练后，这些类型的卷积核最终也能学到。

### 卷积核可视化

卷积网络这些卷积层的所有卷积核完成训练后，会发现：
- 前面几个卷积层的卷积核捕捉和匹配的是一些比较简单的特征，比如边缘；
- 中间几层的卷积核代表的特征变得复杂一些，比如一些边角和斑点；
- 最后几层的特征就会变得特别丰富和复杂。

这些卷积核是从简单到复杂的特征序列。这实际上和 Hubel & Wiesel 的实验结果比较相似，即使在我们并没有明确的让网络去学习这些从简单到复杂的特征，但是给它这种层次结构并经过反向传播训练后，这些类型的卷积核最终也能学到。

<img src="https://raw.githubusercontent.com/YukinoshitaSherry/qycf_picbed/main/img/20250715221945897.png" style="width:75%"><br>

- 激活映射与卷积核可视化联系：

我们有 32 个已经在卷积网络中训练好的 $5 \times 5$ 卷积核，每一个卷积核滑过原始图像得到一张激活映射，将它们可视化，我们可以看出卷积核在原图像匹配和寻找什么。

比如某个卷积核看起来像是一个定向边缘的模板，所以当其滑过图像，在那些有定向边缘的地方会得到较高的值。

之所以称作卷积，只是计算形式上就是卷积，滤波器和信号（图像）的元素相乘后求和。

<br>

## 各层详述

### 卷积层
Convolutional Layer，Conv layer

**卷积层是构建卷积神经网络的核心层**，网络中大部分的计算量都由它产生。

卷积层的参数是由一些可学习的**滤波器（filter）**集合构成的。每个滤波器在宽度和高度上都比较小，但是深度和输入数据一致。

比如卷积神经网络第一层的一个典型的滤波器的尺寸可以是$5 \times 5 \times 3$（宽高都是$5$像素，深度是$3$是因为图像应为颜色通道，所以有3的深度）。

在前向传播的时候，让每个滤波器都在输入数据的宽度和高度上滑动（更精确地说是做卷积），然后计算这个滤波器和输入数据对应每一个区域的内积，最终会生成一个二维的**激活映射**（activation map），激活图给出了在每个空间位置处滤波器的反应。

在每个卷积层上，一般有多个滤波器组成集合（比如12个），每个都会生成一个不同的二维激活映射。将这些激活映射在深度方向上层叠起来就生成了这个卷积层的输出3D数据。

这个3D数据的每一个激活图，都是由一些参数相同的神经元在原图像的不同位置做内积得到的输出数据组成的。每张激活图对应的所有神经元参数都相同（因为实际上就是同一个滤波器在图像上不同位置滑动的结果，每到一个位置就是一个神经元），称为**参数共享**。

- 可视化：<a href="https://img-blog.csdnimg.cn/img_convert/4ee5eaebc612df811f12c78c657279fa.gif">卷积运算</a>

#### 局部连接

卷积层每个神经元和原图像只在一个小区域进行全连接，称为**局部连接**。因为在处理图像这样的高维度输入时，让每个神经元都与前一层中的所有神经元进行全连接是不现实的。

局部连接的空间大小叫做神经元的**感受野（receptive field）**，它的尺寸（其实就是滤波器的空间尺寸）是一个超参数。在深度方向上，这个连接的大小总是和输入量的深度相等。即连接在空间（宽高）上是局部的，但是在深度上总是和输入数据的深度一致。

重复一下之前的例子，一张$32 \times 32 \times 3$的图片，滤波器大小为$5 \times 5 \times 3$。此时感受野尺寸是$5 \times 5$，滤波器的深度需要和原图像深度一致，为$3$。那么神经元的权重个数为$5 \times 5 \times 3=75$个，再加一个偏置项，共$76$个。神经元和原图像一个同样大小的区域是全连接的，共有$75$个连接，但是与整个图像是局部连接的（只在$5 \times 5$的空间上连接），如果是全连接则需要有$3072$个连接。

<img src="https://raw.githubusercontent.com/YukinoshitaSherry/qycf_picbed/main/img/20250715230613503.png" style="width:75%"><br>

- **左边**：红色的是输入数据体（比如 CIFAR-10 中的图像），蓝色的部分是第一个卷积层中的所有神经元。卷积层中的每个神经元都只是与输入数据体的一个局部空间相连，但是与输入数据体的所有深度维度全部相连（所有颜色通道）。在深度方向上有多个神经元（本例中5个），它们都接受输入数据的同一块区域（感受野相同）。深度方向上的神经元参数是不同的。
- **右边**：神经元内部计算还和以前一样，还是计算权重和输入的内积，然后进行激活函数运算，只是它们的连接被限制在一个局部空间，即输入数据只是原图像的一部分。

#### 深度、步长、零填充

卷积层的所有神经元与原始图像卷积后，输出数据体的尺寸由三个超参数控制：**深度（depth），步长（stride）**和**零填充（zero-padding）**。

**① 深度**：卷积层中使用的滤波器往往有多个，**深度就是滤波器的数量**。

- 每个滤波器在输入数据中匹配计算不同的模式。
- 比如第一个卷积层的输入是原始图像，那么在深度维度上的不同神经元将可能被原图像上不同方向的边界，或者是颜色斑点激活。将这些沿着深度方向排列、感受野相同的神经元集合称为**深度列**（depth column），或者**纤维**（fibre）。

**② 步长：步长就是滤波器每次移动跨越的像素数量**。

- 当步长为1，滤波器每次移动1个像素。当步长为2（实际中很少使用比2大的步长），滤波器滑动时每次移动2个像素。这个操作会让输出数据体在空间上变小。

**③ 零填充：在图像的边界外填充零像素点**。

- 滑动时会使输出数据体在空间上变小，比如$32 \times 32$的图像经过一个卷积层输出数据在空间上可能是$28 \times 28$的，经过多层后会迅速收敛。我们不希望这样，于是引入了零填充，零填充有一个良好性质，可以**控制输出数据体的空间尺寸**（最常用的是用来保持输入数据体在空间上的尺寸，这样输入和输出的宽高都相等）。

比如有一个$7 \times 7$的原始图片，滤波器的尺寸是$3 \times 3$，步长为$1$时的输出是$5 \times 5$；步长为$2$时输出是$3 \times 3$，但步长是$3$的时候尺寸不再适合。


<img src="https://raw.githubusercontent.com/YukinoshitaSherry/qycf_picbed/main/img/20250715222023990.png" style="width:75%"><br>

假设图片的尺寸是$N \times N$，滤波器尺寸是$F \times F$，步长为$S$，则输出数据的尺寸为：$(N-F)/S +1$。所以当$N=7$，$F=3$：

- $S=1$时，输出为$5$
- $S=2$时，输出为$3$
- $S=3$时，输出为$2.333$，显然不合理

所以步长的设置不合理会导致网络的异常，引入零填充可一定程度解决这个问题。


<img src="https://raw.githubusercontent.com/YukinoshitaSherry/qycf_picbed/main/img/20250715222036490.png" style="width:75%"><br>

下面考虑加入零填充的情形。在$7 \times 7$的图像外面加入一圈零像素，滤波器尺寸仍为$3 \times 3$，步长为1，此时的输出尺寸应该是多少？答案是$7 \times 7$，因为此时的原图像相当于变成$9 \times 9$。此时的输出数据空间尺寸和输入的相同。

综上，可得输出数据尺寸的计算公式：

假如输入数据体尺寸$W \times W$，卷积层中神经元的感受野尺寸$F \times F$，步长$S$和零填充的数量$P$，则输出数据体的空间尺寸为$(W+2P-F)/S+1$。

- 比如上面输入是$7 \times 7$，滤波器是$3 \times 3$，步长为1，填充为1，那么就能得到一个$7 \times 7$的输出。

一般来说，当步长$S=1$时，为保证输入尺寸和输出尺寸相同，零填充的数量为：$P=(F-1)/2$。

- 考虑最初的问题，一张$32 \times 32 \times 3$的图像，经过有10个$5 \times 5 \times 3$滤波器的卷积层，步长为1，零填充数量为2，则输出的尺寸为？显然是$32 \times 32 \times 10$。这是因为滤波器尺寸$5$步长$1$填充$2$可以保持空间尺寸，滤波器的数量又决定了输出的深度。

**那么这个卷积层有多少个参数呢？**

- 10个滤波器每个有$5 \times 5 \times 3+1=76$个参数，所以共有$760$个参数。

**那么这个卷积层一共有多少个神经元呢？**

- 答案是$32 \times 32 \times 10$，因为输出数据的每个数据点，都由一个神经元产生。也就是说**输出数据体的尺寸，就代表着神经元的排列方式**。

但是，既然有$32 \times 32 \times 10$个神经元，每个神经元的参数为76，那为什么只有760个参数呢？大家可以在后面的**参数共享**部分可以找到答案。

AlexNet神经网络架构，赢得了2012年的 ImageNet 挑战，它的结构中：

- 输入图像的尺寸是$[227 \times 227 \times 3]$
- 在第一个卷积层，神经元使用的感受野尺寸$F=11$，步长$S=4$，不使用零填充$P=0$。因为$(227-11)/4+1=55$，卷积层的深度$K=96$，则卷积层的输出数据体尺寸为$[55 \times 55 \times 96]$。$55 \times 55 \times 96$个神经元中，每个都和输入数据体中一个尺寸为$[11 \times 11 \times 3]$的区域全连接。在深度列上的96个神经元都是与输入数据体中同一个$[11 \times 11 \times 3]$区域连接，但是权重不同。

#### 参数共享机制

在卷积层中使用参数共享是用来控制参数的数量。

在第一个卷积层就有$55 \times 55 \times 96=290,400$个神经元（假设神经元都是独立的）

- 因为一个滤波器每滑到一个位置，就对应一个神经元，得到一个神经元输出。滑过所有位置后的输出数据空间尺寸为$55 \times 55$，对应着有$55 \times 55$个神经元。再加上一共有96个滤波器，所以为$55 \times 55 \times 96$。
- 每个神经元有$11 \times 11 \times 3+1=364$个参数。将这些合起来就是$290400 \times 364=105,705,600$个参数。单单第一层就有这么多参数，显然这个数目是非常大的。

作一个合理的假设：**如果一个特征在计算某个空间位置$(x,y)$的时候有用，那么它在计算另一个不同位置$(x_2,y_2)$的时候也有用**。

- 参数共享的假设是有道理的：如果在图像某些地方探测到一个水平的边界是很重要的，那么在其他一些地方也会同样是有用的，这是因为图像结构具有平移不变性。

基于这个假设，可以显著地减少参数数量。也是基于这个假设，滤波器可以在原图片上滑动。

- 可视化：<a href="https://img-blog.csdnimg.cn/img_convert/5e4979afec9e3edab4d74e0e801d684d.gif">滤波器如何滑动</a>

如果我们将深度维度上一个单独的2维切片看做**深度切片**（depth slice），比如这个尺寸为$[55 \times 55 \times 96]$的输出数据体就有96个深度切片，每个尺寸为$[55 \times 55]$。在每个深度切片上的神经元都使用同样的权重和偏置项。

在这样的参数共享下，例子中的第一个卷积层就只有96个不同的参数集了，一个参数集对应一个深度切片，共有$96 \times (11 \times 11 \times 3+1)=34,944$个不同的参数（包括偏置项）。

在每个深度切片中的$55 \times 55$个权重使用的都是同样的参数。

**在反向传播的时候，需要计算每个神经元对它的权重的梯度，所以需要把同一个深度切片上的所有神经元对权重的梯度进行累加，这样就得到了对这个共享权重的梯度。这样，每个切片只更新一个权重集**。

**补充解释**：正是因为参数共享，卷积层的前向传播在每个深度切片中可以看做是在计算神经元权重和输入数据体的**卷积**（这就是「卷积层」名字由来）。这也是为什么总是将这些权重集合称为**滤波器（filter）**（或**卷积核（kernel）**），因为它们和输入进行了卷积。

有时候参数共享假设可能没有意义，特别是当卷积神经网络的输入图像是一些明确的中心结构时候。这时候我们就应该期望在图片的不同位置学习到完全不同的特征。一个具体的例子就是输入图像是人脸，人脸一般都处于图片中心。你可能期望不同的特征，比如眼睛特征或者头发特征可能（也应该）会在图片的不同位置被学习。在这个例子中，通常就放松参数共享的限制，将层称为**局部连接层**（Locally-Connected Layer）。

<br>

### 池化层
Pooling Layer，POOL Layer

通常，在连续的卷积层之间会周期性地插入一个**池化层**。它的**作用是逐渐降低数据体的空间（宽、高）尺寸，这样的话就能减少网络中参数的数量**，使得计算资源耗费变少，也能有效控制过拟合。

池化层最常用的是 MAX 操作，对输入数据体的每一个深度切片独立进行操作，改变它的空间尺寸。最常见的形式是使用尺寸$2 \times 2$的滤波器，以步长为$2$来对每个深度切片进行**降采样**，将其中$75\%$的激活信息都丢掉。每个 MAX 操作是从$4$个数字中取最大值（也就是在深度切片中某个$2 \times 2$的区域）。**深度方向保持不变**，不进行降采样。

池化层也不用零填充，并且池化滤波器间一般没有重叠，步长等于滤波器尺寸。

#### 池化层的性质

- 输入数据体尺寸：$W_1 \times H_1 \times D_1$
- 有两个超参数：池化尺寸$F$，一般为$2$、$3$；步长$S$，一般为$2$。实际上max池化层一般只有两种超参数设置方式：$F=3$，$S=2$，叫做重叠汇聚（overlapping pooling）；另一种更常用的是$F=2$，$S=2$
- 输出数据体尺寸：$W_2 \times H_2 \times D_2$，其中：
    - $W_2 = (W_1 - F)/S + 1$
    - $H_2 = (H_1 - F)/S + 1$
    - $D_2 = D_1$
- 因为对输入进行的是固定函数计算，所以没有引入参数。此外，在池化层中很少使用零填充。

#### 池化方式

<img src="https://raw.githubusercontent.com/YukinoshitaSherry/qycf_picbed/main/img/20250715231356978.png" style="width:75%"><br>

除了最大池化，池化单元还可以使用其他的函数，比如平均池化（average pooling）或 L2 范式池化（L2-norm pooling）。平均池化历史上比较常用，但是现在已经很少使用了。

池化层在输入数据体的每个深度切片上，独立地对其进行空间上（高度、宽度）的降采样。

- 最常用的降采样操作是取最大值，也就是最大池化，这里步长为$2$，每个取最大值操作是从$4$个数字中选取（即$2 \times 2$的方块区域中）。

**反向传播**

- $\max(x,y)$函数的反向传播可以简单理解为将梯度只沿最大的数回传。
- 在前向传播经过池化层的时候，通常会把池中最大元素的索引记录下来（有时这个也叫作**道岔**switches），这样在反向传播的时候梯度路由就很高效。

**一些争议**

- 很多人认为可以不使用池化层。比如在 Striving for Simplicity: The All Convolutional Net 一文中，提出使用一种只有重复的卷积层组成的结构，不再使用池化层，通过在卷积层中使用更大的步长来降低数据体的尺寸。
- 有发现认为，在训练一个良好的生成模型时，弃用池化层也是很重要的。比如变化自编码器（VAEs：variational autoencoders）和生成性对抗网络（GANs：generative adversarial networks）。现在看来，未来的卷积网络结构中，可能会很少使用甚至不使用池化层。

### 归一化层
Normalization Layer

在卷积神经网络的结构中，提出了一些归一化层的概念，想法是为了实现在生物大脑中观测到的抑制机制。但是这些层渐渐都不再流行，因为实践证明它们的效果即使存在，也是极其有限的。

对于不同类型的归一化层，可以看看nAlex Krizhevskyn的关于 cuda-convnet library API 的讨论。

### 全连接层
Fully-connected Layer，FC Layer

全连接层，顾名思义，神经元对于前一层中的所有激活数据是全连接的，这个和常规神经网络中一样，通常会把前一层数组拉成一个向量，与$W$的每个行向量进行点积，得到每一类的分数。

最后一个池化层输出的结果是数据经过整个网络累计得到的，前几个卷积层可能检测一些比较简单的特征比如边缘，得到边缘图后输入到下一个卷积层，然后进行更复杂的检测，这样层层下来，最后一层的结果可以看成是一组符合模板的激活情况，比较大的值表明之前的所有检测结果都比较大，激活程度高，这样就汇聚了大量的信息。

虽然输出的数据比较简单，但却是非常复杂的滤波器（或特征）激活后的情况，特征在卷积核中体现。

- 第一层卷积网络输出的结果比较复杂，因为第一层的卷积核比较简单，很容易就激活了；
- 最后一层的卷积核非常复杂，所以输出的激活图看起来就会很简单，因为激活比较困难。但是这个激活图却能说明复杂特征的激活程度，用来评分是非常合理的。

#### 全连接层转化为卷积层

全连接层和卷积层之间唯一的不同就是卷积层中的神经元只与输入数据中的一个局部区域连接，并且在同一个深度切片上的神经元共享参数。然而在两类层中，神经元都是计算点积，所以它们的函数形式是一样的。因此，将此两者相互转化是可能的：

**① 对于任一个卷积层，都存在一个能实现和它一样的前向传播函数的全连接层**。

- 权重矩阵是一个巨大的矩阵，除了某些特定块（这是因为有局部连接），其余部分都是零。而在其中大部分块中，元素都是相等的（因为参数共享）。

**② 反过来，任何全连接层都可以被转化为卷积层**。

- 比如，一个$K=4096$（即有$4096$个类别，$W$有$4096$个列向量）的全连接层，输入数据体的尺寸是$7 \times 7 \times 512$，那么W的每个列向量长度为$7 \times 7 \times 512$，全连接之后的输出为$1 \times 4096$。
- 这个全连接层可以被等效地看做一个$F=7$，$P=0$，$S=1$，$K=4096$的卷积层。换句话说，就是将滤波器的尺寸设置为和输入数据体的尺寸一致也是$7 \times 7 \times 512$，这样两者卷积的结果就是一个实数。又因为有$4096$个滤波器，所以输出将变成$1 \times 1 \times 4096$，这个结果就和使用初始的那个全连接层一样了。

两种转换的示意图如下图所示：
<img src="https://raw.githubusercontent.com/YukinoshitaSherry/qycf_picbed/main/img/20250715222411214.png" style="width:75%"><br>
上述两种转换中，全连接层转化为卷积层在实际运用中更加有用。

假设一个卷积神经网络的输入是$224 \times 224 \times 3$的图像，一系列的卷积层和池化层将图像数据变为尺寸为$7 \times 7 \times 512$的激活数据体（在 AlexNet 中就是这样，通过使用5个池化层来对输入数据进行空间上的降采样，每次尺寸下降一半，所以最终空间尺寸为$224/2/2/2/2/2=7$）。

全连接层中，AlexNet 先使用了两个尺寸为$4096$的全连接层，然后又使用了一个有1000 个神经元的全连接层用于计算分类评分。

我们可以将这 3 个全连接层中的任意一个转化为卷积层：

- 针对第一个连接区域是$[7 \times 7 \times 512]$的全连接层，令其滤波器尺寸为$7 \times 7 \times 512$，$K=4096$，这样输出数据体就为$[1 \times 1 \times 4096]$了；
- 针对第二个全连接层，令其滤波器尺寸为$1 \times 1 \times 4096$，$K=4096$，这样输出数据体仍为$[1 \times 1 \times 4096]$；
- 对最后一个全连接层也做类似的，令其滤波器尺寸为$1 \times 1 \times 4096$，$K=1000$，最终输出为$[1 \times 1 \times 1000]$。

我们注意到，每次类似的变换，都需要把全连接层的权重$W$重塑成卷积层中和输入数据尺寸相同的滤波器。这个转化最大的意义是让一些计算更高效：

- 让卷积网络在一张更大的输入图片上滑动（即把一张更大的图片的不同区域都分别带入到卷积网络，得到每个区域的得分），得到多个输出，这样的转化可以让我们在单个前向传播的过程中完成上述的操作。

比如将$224 \times 224 \times 3$的图片经过卷积网络（不包括最后三个全连接层）后得到$7 \times 7 \times 512$的激活数据体（降采样5次，除32）。然后经过第一个全连接层，该全连接层的神经元需要$7 \times 7 \times 512$个参数。

如果换成一张$384 \times 384$的大图片经过同样的网络（不包括最后三个全连接层）等效输出尺寸为$12 \times 12 \times 512$（$384/32 = 12$），如果直接用来通过全连接层，由于尺寸不同，会无法通过。

- 这时就需要把$384 \times 384$的图片切成$6 \times 6$个$224 \times 224$的小图像依次通过卷积网络，这样全连接层之前的输出为36个$7 \times 7 \times 512$的激活数据体，远远大于$12 \times 12 \times 512$，所以由于全连接层的存在，导致大量的重复运算。
- 但是如果将3个全连接层转化来的3个卷积层，就不会存在尺寸的问题，$384 \times 384$的图片可以直接通过转化后的卷积网络，最终得到$6 \times 6 \times 1000$的输出（因为$(12 - 7)/1 + 1 = 6$或$(384-224)/32+1 = 6$）。这样我们可以在$384 \times 384$图像上一次得到$6 \times 6$个分类得分数组，而不是独立的得到36个大小为$[1 \times 1 \times 1000]$的得分数组，大大节省计算量。



## 卷积神经网络层的排列与尺寸设置

### 层的排列规律

卷积神经网络通常是由三种层构成：卷积层，池化层和全连接层（简称FC）。ReLU 激活函数也应该算是一层，它逐元素地进行激活函数操作。

卷积神经网络最常见的形式就是将一些卷积层和 ReLU 层放在一起，其后紧跟池化层，然后重复如此直到图像在空间上被缩小到一个足够小的尺寸，在某个地方过渡成全连接层也较为常见。最后的全连接层得到输出，比如分类评分等。

换句话说，最常见的卷积神经网络结构如下：

1. `INPUT → [[CONV → RELU]*N → POOL?]*M → [FC → RELU]*K → FC`

其中 `*` 指的是重复次数，`POOL?` 指的是一个可选的池化层。其中 $N \geq 0$（通常 $N \leq 3$），$M \geq 0$，$K \geq 0$（通常 $K < 3$）。

例如，下面是一些常见的网络结构规律：

- INPUT → FC，实现一个线性分类器，此处 $N = M = K = 0$；
- INPUT → CONV → RELU → FC；
- INPUT → [CONV → RELU → POOL]*2 → FC → RELU → FC，此时在每个池化层前只有一个卷积层；
- INPUT → [CONV → RELU → CONV → RELU → POOL]_3 → [FC → RELU]_2 → FC，此时每个池化层前有两个卷积层，这个思路适用于更大更深的网络，因为在执行具有破坏性的池化操作前，多重的卷积层可以从输入数据中学习到更多的复杂特征。

**经验**：**几个小滤波器卷积层的组合比一个大滤波器卷积层好**。

假设你一层一层地重叠了$3$个$3 \times 3$的卷积层（层与层之间有非线性激活函数）。

- 第一个卷积层中的每个神经元都对输入数据体有一个$3 \times 3$的感受野
- 第二个卷积层上的神经元对第一个卷积层有一个$3 \times 3$的感受野，也就是对输入数据体有$5 \times 5$的感受野（32-30-28）。
- 在第三个卷积层上的神经元对第二个卷积层有$3 \times 3$的感受野，也就是对输入数据体有$7 \times 7$的感受野。

下图是第1层和第2层卷积层的堆叠感受野示意图：
<img src="https://raw.githubusercontent.com/YukinoshitaSherry/qycf_picbed/main/img/20250715222353346.png" style="width:75%"><br>

假设不采用这3个$3 \times 3$的卷积层，而是使用一个单独的有$7 \times 7$的感受野的卷积层，那么所有神经元的感受野也是$7 \times 7$，但是就有一些缺点：

- ① 多个卷积层与非线性的激活层交替的结构，比单一卷积层的结构更能提取出深层的更好的特征。
- ② 假设所有的数据有$C$个通道，即输入输出数据深度均为$C$，那么单独的$7 \times 7$卷积层将会包含$C \times (7 \times 7 \times C) = 49 C^2$个参数，而3个$3 \times 3$的卷积层的组合仅有$3 \times (C \times (3 \times 3 \times C)) = 27 C^2$个参数。

直观说来，最好选择带有小滤波器的卷积层组合，而不是用一个带有大的滤波器的卷积层。前者可以表达出输入数据中更多个强力特征，使用的参数也更少。

唯一的不足是，在进行反向传播时，中间的卷积层可能会导致占用更多的内存。

### 层的尺寸设置规律

#### 输入层

原始输入图像，经常设置为$2^N$形式。常用数字包括32（比如CIFAR-10），64，96（比如STL-10）或224（比如ImageNet卷积神经网络）、384和512。

#### 卷积层

- 应该使用小尺寸滤波器（比如$3 \times 3$或最多$5 \times 5$），使用步长$S=1$。
- 要对输入数据进行零填充，这样卷积层就不会改变输入数据在空间维度上的尺寸。比如
    - 当$F=3$，那就使用$P=1$来保持输入尺寸；
    - 当$F=5$，那就使用$P=2$来保持输入尺寸。
    - 一般对于任意$F$，当$P=(F-1)/2$的时候能保持输入尺寸。
- 如果必须使用更大的滤波器尺寸（比如$7 \times 7$之类），通常只用在第一个输入原始图像的卷积层上。

#### 池化层

- 负责对输入数据的空间维度进行降采样。
- 最常用的设置是用用$2 \times 2$感受野（即$F=2$）的最大值汇聚，步长为$2$（$S=2$）。注意这一操作将会把输入数据中 75% 的激活数据丢弃（因为对宽度和高度都进行了 2 的降采样）。
- 另一个不那么常用的设置是使用$3 \times 3$的感受野，步长为2。最大值汇聚的感受野尺寸很少有超过3的，因为汇聚操作过于激烈，易造成数据信息丢失，这通常会导致算法性能变差。

在某些案例（尤其是早期的卷积神经网络结构）中，基于前面的各种规则，内存的使用量迅速飙升。

- 例如，使用64个尺寸为$3 \times 3$的滤波器对$224 \times 224 \times 3$的图像进行卷积，零填充为1，得到的激活数据体尺寸是$[224 \times 224 \times 64]$。这个数量就是一千万的激活数据，或者就是72MB的内存（每张图就是这么多，激活函数和梯度都是）。

因为GPU通常因为内存导致性能瓶颈，所以做出一些妥协是必须的。在实践中，人们倾向于在网络的第一个卷积层做出妥协。

- 例如，可以妥协可能是在第一个卷积层使用步长为$2$，尺寸为$7 \times 7$的滤波器（比如在ZFnet中）。在AlexNet中，滤波器的尺寸的$11 \times 11$，步长为4。


